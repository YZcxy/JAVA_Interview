## JAVA基础知识点
Q：JAVA中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）  
A：不需要。JAVA由于虚拟机的关系，屏蔽了大小端问题，需要知道的话可以用 ByteOrder.nativeOrder() 查询。在操作 ByteBuffer 中，也可以使用 ByteBuffer.order() 进行设置。  
***
Q：JAVA的基本数据类型以及大小？  
A：一共有8中基本数据类型：  
- 整数值型：byte(1字节)、short(2字节)、int(4字节)、long(8字节)  
- 字符型：char(2字节)  
- 浮点类型：float(4字节)、double(8字节)  
- 布尔型：boolean(无大小)  

**整数值型默认为int，浮点类型默认为 double，long 和 float 需要添加后缀才能表示。**  

***
Q：JAVA中 boolean 类型的大小？  
A：boolean 类型无空间大小，布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。在不同场景不同虚拟机，所占用的字节是不同的。  
***
Q：不可变类型有哪几种？  
A：8中基本数据类型的**包装型**，以及 String。String 是因为由`private final char[] value;`修饰，所以final不可变。  
不仅限于以上，还有 BigInteger、BigDecimal 等等。  
***
Q：什么是不可变类型？  
A：变量的值一旦发生变化，其对应的内存地址也发生了变化。  
***
Q：对象中的成员如果是基本数据类型，会被初始化吗？  
A：会，会被初始化为0或者 false。  
***
Q：什么时候不能隐式转换？  
A： 如果会丢失精度，则不能隐式转化，比如 long 转 int 或者 double 转 long 这种。 编译器会强制我们使用强制转化。 
***
Q：8种基本数据类型的优先级排序是？  
A：byte<(short/char)<int<long<float<double，隐式转换都是从低往高转换。  
***
Q：包装类型Integer的大小比较？  
```java
Integer num1 = 128,num2 = 128;
System.out.println(num1==num2);
```
A：输入为 false。因为值在-128~127范围内的 Integer 可以直接用==比较大小，这时候 Integer 对象会直接使用缓存对象，所以地址一样。如果超出了范围，Integer 会新生成对象，地址就不一样。  
***
Q：浮点数相等的比较方式？  
A：如果要判断浮点数是否相等，需要使用下面的方法：  
``` java
if(Math.abs(a-b))<1E-6F)
```
因为计算机无法直接表示一个浮点数，一般采用 IEEE754 标准来表示，所以处理浮点数是有误差的，不能直接用==判断。  
***
Q：String、StringBuffer、StringBuilder 的区别？
A：  
- String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。  
- StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。  
***
Q：`String s = new String("xyz")` 会创建几个对象？  
A：
- 首先，在 String 池内找，找到 "xyz" 字符串，不创建 "xyz" 对应的 String 对象，否则创建一个对象。  
- 然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。  
***
Q：JAVA有哪些修饰符？  
A：有四种修饰符，范围从大到小：  
- public：可被所有使用
- protect：只能被自己和子类使用，或者同一个包路径
- default：只能同一个包内的都可以访问
- private：只能被自己使用

***
Q：final有什么作用？  
A：final修饰的值不可以被改变。如果是基本类型，则指值不能被改变；如果是引用类型，则指对象的引用不可改变，但是引用的内容是可以改变的；如果是一个类，则这个类无法被继承。   
***
Q：finally有什么作用？  
A：在异常处理时提供`finally`块来执行最后的操作。   
以下四种特殊情况，finally 不会被执行：  
- 在 finally 语句块中发生了异常  
- 在前面的代码中调用了 `System.exit()` 退出程序  
- 程序所在的线程死亡。  
- 关闭CPU  

***
Q：finalize有什么作用？  
A：finalize 是一个方法，Java允许使用 `finalize()` 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，子类可以重写这个方法实现清理工作，这个方法是由垃圾收集器在确定这个对象要被回收时调用。  
***
Q：重载和重写的区别？  
A：
1. 重写 override  
- 方法名、参数、返回值相同
- 子类不能缩小父类方法的访问权限
- 子类不能抛出比父类更多的异常（但子类可以不抛出异常）
- 存在于父类与子类之间
- final 方法不能被重写  
2. 重载 overload  
- 参数类型、个数、顺序至少有一个不相同
- 不能重载只有返回值不同的方法
- 存在于父类和子类、同类中  

***
Q：枚举可以被继承吗？  
A：不可以，因为所有的枚举 `enum` 自身都已经继承自 Enum 类，而 Java 不支持多继承，所以不可以继承。  
***


