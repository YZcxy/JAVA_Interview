## JAVA基础知识点

Q：什么是面向对象？  
A：面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：  
- 代码开发模块化，更易维护和修改。
- 代码复用性强。
- 增强代码的可靠性和灵活性。
- 增加代码的可读性。
***
Q：请说说面向对象的特征？  
A：四个特征：封装、继承、多态、抽象。  
***
Q：JDK、JRE、JVM 分别是什么关系？  
A：JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及  JRE。JRE 中又包含了 JVM。  
***
Q：什么是 Java 字节码？  
A：因为 Java 是编译执行语言。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码(即扩展名为 .class 的文件)。  
> Java 源代码
=> 编译器 => JVM 可执行的 Java 字节码(即虚拟指令)
=> JVM => JVM 中解释器 => 机器可执行的二进制机器码 => 程序运行  

***
Q：JAVA中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）  
A：不需要。JAVA由于虚拟机的关系，屏蔽了大小端问题，需要知道的话可以用 `ByteOrder.nativeOrder()` 查询。在操作 ByteBuffer 中，也可以使用 ByteBuffer.order() 进行设置。  

***
Q：JAVA的基本数据类型以及大小？  
A：一共有8中基本数据类型：  
- 整数值型：byte(1字节)、short(2字节)、int(4字节)、long(8字节)  
- 字符型：char(2字节)  
- 浮点类型：float(4字节)、double(8字节)  
- 布尔型：boolean(无大小)  

**整数值型默认为int，浮点类型默认为 double，long 和 float 需要添加后缀才能表示。**  

***
Q：JAVA中 boolean 类型的大小？  
A：boolean 类型无空间大小，布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。在不同场景不同虚拟机，所占用的字节是不同的。  
***
Q：不可变类型有哪几种？  
A：8中基本数据类型的**包装型**，以及 String。String 是因为由`private final char[] value;`修饰，所以final不可变。  
不仅限于以上，还有 BigInteger、BigDecimal 等等。  
***
Q：什么是不可变类型？  
A：变量的值一旦发生变化，其对应的内存地址也发生了变化。  
***
Q：对象中的成员如果是基本数据类型，会被初始化吗？  
A：会，会被初始化为0或者 false。  
***
Q：什么时候不能隐式转换？  
A： 如果会丢失精度，则不能隐式转化，比如 long 转 int 或者 double 转 long 这种。 编译器会强制我们使用强制转化。 
***
Q：8种基本数据类型的优先级排序是？  
A：byte<(short/char)<int<long<float<double，隐式转换都是从低往高转换。  
***
Q：包装类型Integer的大小比较？  
```java
Integer num1 = 128,num2 = 128;
System.out.println(num1==num2);
```
A：输入为 false。因为值在-128~127范围内的 Integer 可以直接用==比较大小，这时候 Integer 对象会直接使用缓存对象，所以地址一样。如果超出了范围，Integer 会新生成对象，地址就不一样。  
***
Q：char 型变量中能不能存贮一个中文汉字？  
A：在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。  
***
Q：浮点数相等的比较方式？  
A：如果要判断浮点数是否相等，需要使用下面的方法：  

``` java
if(Math.abs(a-b))<1E-6F)
```
因为计算机无法直接表示一个浮点数，一般采用 IEEE754 标准来表示，所以处理浮点数是有误差的，不能直接用==判断。  
***
Q：String、StringBuffer、StringBuilder 的区别？   
A：区别如下：  
- String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。  
- StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。  
***
Q：`String s = new String("xyz")` 会创建几个对象？  
A：一个或者两个：  

- 首先，在 String 池内找，找到 "xyz" 字符串，不创建 "xyz" 对应的 String 对象，否则创建一个对象。  
- 然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。  
***
Q：JAVA有哪些修饰符？  
A：有四种修饰符，范围从大到小：  
- public：可被所有使用
- protect：只能被自己和子类使用，或者同一个包路径
- default：只能同一个包内的都可以访问
- private：只能被自己使用

***
Q：final有什么作用？  
A：final修饰的值不可以被改变。如果是基本类型，则指值不能被改变；如果是引用类型，则指对象的引用不可改变，但是引用的内容是可以改变的；如果是一个类，则这个类无法被继承。   
***
Q：finally有什么作用？  
A：在异常处理时提供`finally`块来执行最后的操作。   
以下四种特殊情况，finally 不会被执行：  
- 在 finally 语句块中发生了异常  
- 在前面的代码中调用了 `System.exit()` 退出程序  
- 程序所在的线程死亡。  
- 关闭CPU  

***
Q：finalize有什么作用？  
A：finalize 是一个方法，Java允许使用 `finalize()` 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，子类可以重写这个方法实现清理工作，这个方法是由垃圾收集器在确定这个对象要被回收时调用。  
***
Q：重载和重写的区别？  
A：
1. 重写 override  
- 方法名、参数、返回值相同
- 子类不能缩小父类方法的访问权限
- 子类不能抛出比父类更多的异常（但子类可以不抛出异常）
- 存在于父类与子类之间
- final 方法不能被重写  
2. 重载 overload  
- 参数类型、个数、顺序至少有一个不相同
- 不能重载只有返回值不同的方法
- 存在于父类和子类、同类中  

***
Q：枚举可以被继承吗？  
A：不可以，因为所有的枚举 `enum` 自身都已经继承自 Enum 类，而 Java 不支持多继承，所以不可以继承。  
***
Q ：抽象类和接口有什么区别？  
A：从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。  
- Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。
- Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。
- Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。
- 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 `main(String[] args)` 方法的话是可以被调用的。
***
Q：类的实例化顺序？  
A：初始化顺序如下：  
1. 父类静态变量
2. 父类静态代码块
3. 子类静态变量、
4. 子类静态代码块
5. 父类非静态变量（父类实例成员变量）
6. 父类构造函数
7. 子类非静态变量（子类实例成员变量）
8. 子类构造函数
***
Q：什么是内部类？  
A：就是在一个类、接口或者方法的内部创建另一个类。内部类提供了更好的封装，除了该外围类，其他类都不能访问。可以访问创建它的外部类对象的成员，包括私有成员。  
***
Q：什么是 Java IO？  
A：Java IO 相关的类，在`java.io` 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。如下图所示：  
![](http://static.iocoder.cn/eb408ac849a679b09941be7ebd734768)
***
Q：什么是 Java 序列化？  
A：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。反序列化的过程，则是和序列化相反的过程。  
***
Q：如何实现 Java 序列化？  
A：将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。  
***
Q：Java 序列化中，如果有些字段不想进行序列化怎么办？  
A：对于不想进行序列化的变量，使用 transient 关键字修饰。transient 只能修饰变量，不能修饰类和方法。  
***
Q：如何实现对象克隆？  
A：一般来说，有两种方式：  
1. 实现 Cloneable 接口，并重写 Object 类中的 `clone()` 方法。可以实现浅克隆，也可以实现深克隆。
2. 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。
***
Q：error 和 exception 有什么区别？  
A：基于共同的祖先 `java.lang.Throwable` 类，区别如下：  
- Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。
  - 例如：内存资源不足等。
  - 对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。
- Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。
  - RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。
  - CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。

***
Q：请列出 5 个运行时异常？  
A：如下：  
- NullPointerException
- IndexOutOfBoundsException
- ClassCastException
- ArrayStoreException
- BufferOverflowException
***
Q：反射的用途及实现？  
A：Java 反射机制主要提供了以下功能：  
- 在运行时构造一个类的对象。
- 判断一个类所具有的成员变量和方法。
- 调用一个对象的方法。
- 生成动态代理。
反射的应用很多，很多框架都有用到：  
- Spring 框架的 IoC 基于反射创建对象和设置依赖属性。
- Spring MVC 的请求调用对应方法，也是通过反射。
- JDBC 的 `Class#forName(String className)` 方法，也是使用反射。
***
Q：反射中，Class.forName 和 ClassLoader 区别？  
A：这两者，都可用来对类进行加载。差别在于：  
- `Class#forName(...)` 方法，除了将类的 .class 文件加载到JVM 中之外，还会对类进行解释，执行类中的 static 块。
- ClassLoader 只干一件事情，就是将 .class 文件加载到 JVM 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。
***
Q：什么是注解？  
A：Java 注解又称为标注，是 Java从1.5 开始支持加入源码的特殊语法`元数据`；Java 中的类、方法、变量、参数、包都可以被注解。
***
Q：什么时候用断言（assert）？  
A：断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。  
***
Q：Java 对象创建的方式？  
A：有以下五种方式：  
1. 使用 new 关键字创建对象。
2. 使用 Class 类的 newInstance 方法(反射机制)。
3. 使用 Constructor 类的 newInstance 方法(反射机制)。
4. 使用 clone 方法创建对象。
5. 使用(反)序列化机制创建对象。
