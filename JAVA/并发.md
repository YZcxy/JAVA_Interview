# JAVA并发知识点

## Java线程

Q：程序、进程、线程的基本概念是什么？   
A：概念如下：
- 程序：包含指令和数据的文件，存储在磁盘或其他存储设备中，也就是说程序是静态的代码。  
- 进程：进程是操作系统运行程序的基本单位，当程序被执行时，会被操作系统载入到内存中，在计算机中一个指令一个指令的执行，同时占用着相关的CPU，内存，IO等资源，因此进程是动态的。  
- 线程：线程与进程类似，但是线程是更小的执行单位，一个进程可以在执行过程中产生多个线程。与进程不同，同类的多个线程共享同一块内存空间和系统资源，所以各个线程之间进行工作切换的负担很小。因此线程也被称为轻量级的进程。  
***
Q：守护线程是什么？  
A：任何线程都可以通过 `setDaemon()` 方法来设置是否为守护线程。守护线程是用来为其他线程服务的，JVM 会等待非守护线程执行完毕后才关闭，但是不会等待守护线程。JVM 的垃圾回收线程就是一个守护线程。  

***
Q：什么是多线程上下文切换？   
A：多线程会共同使用一组计算机上的CPU，而往往线程数是大于CPU数量的，为了让各个线程都有执行机会，就需要轮转使用CPU。  
在上下文切换过程中，CPU会停止处理当前运行的程序，保存好当前程序运行的具体位置后以便之后继续运行。页码信息会一直保存在CPU的内存中，直到再次被调用。  
***
Q：Java中用到的线程调度算法？  
A：操作系统中有四种调度算法，Java一般会使用两种调度模型：  
- 分时调度模型：让所有的线程轮流获得 CPU 的使用权，并且平均分配每个线程占用的时间片。  
- 抢占式调度模型：优先让可运行池中优先级高的线程占用 CPU，如果优先级相同就随机选择。处于运行状态的线程会一直运行。  
***
Q：什么是线程饥饿？  
A：一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。Java 中可能导致线程饥饿的原因有以下几点：  
- 高优先级线程吞噬所有低优先级线程的 CPU 时间。
- 线程被永久堵塞在一个等待进入同步块的状态。
- 线程在等待一个也处于等待的对象。
***
Q：线程的生命周期？  
A：线程一共有五种状态：  

- 新建(new)：当创建一个线程实例时，此线程就进入了新建状态。`Thread t = new Thread()`。  
- 可运行状态(runnable)：线程被调用了 start 方法时，该线程就进入可运行线程池中，等待线程调度选中，分配 CPU 的使用权。`t.start()`。  
- 运行状态(running)： 线程获得了 CPU 的使用权，正在执行任务( run 方法)。此时除非线程自动放弃了 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。  
- 死亡(dead)：当线程执行完或者被其他线程杀死，就进入了死亡状态。  
- 阻塞(blocked)：由于某种原因导致正在运行的线程让出了 CPU 资源并暂停执行，即进入了阻塞状态。有以下三种情况：  
  - `sleep()`：使当前线程进入睡眠，不释放锁。  
  - `wait()`：进入等待状态，等待 notify，释放锁。 
  - `suspend()`：进入等待状态，等待 resume，不释放锁，所以弃用了。  

![thread](http://static.iocoder.cn/04a277229fd3b24e058417f9c571681c)
***
Q：创建线程的方式？  
A：Java 中创建线程主要有三种方式：  
1. 继承 Thread 类。  
2. 实现 Runnable 接口。  
3. 通过 Callable 和 Future 结合。  
方式一方便简单，但是已经继承了 Thread 类，就无法继承其他类了。  
方式二和方式三通过实现接口，还可以继承其他类；**最重要**可以使用线程池执行任务。  
***
Q：start 和 run 方法有什么区别？  
A：`start()`方法会创建新的线程，执行 run 里面的代码。`run()`方法等于直接在当前线程调用 run，把 run 当做了一个普通的方法。  
***
Q：为什么 Thread 要废弃 stop 方法？  
A：因为调用 `stop()` 方法，会直接终止掉线程并且释放掉锁，线程内部是无法感知的。被突然的停止，可能就会导致有些工作没有完成，或者只完成了一半。  

***
Q：那么应该如何停止线程呢？  
A：一般来说，有两种方式：  
- 使用退出标志，这个 flag 变量要多线程可见。   
- 应该结合 `interrupt()` 和 `isInterrupted()` 使用。  
`interrupt()` 方法可以使一个被阻塞的线程抛出一个中断异常，可以捕获这个异常进行最后的收尾工作；如果线程没有被阻塞，也可以使用  `isInterrupted()` 来判断当前线程是否应该准备结束任务。   
***
Q：为什么不建议使用 suspend 和 resume 方法？  
A：suspend 和 resume 的作用是让一个线程暂停，但是线程不会释放锁。所以如果A线程使B线程暂停，A线程又依赖B线程的锁，那么就会造成死锁。  

***
Q：用什么方案替代 suspend 和 resume 呢？  
A：解决方案就是使用 `wait()` 和 `notify()` 方法实现线程阻塞。调用线程的 `wait()` 方法，线程会进入阻塞状态，并且释放锁；当调用 `notify()` 的时候会随机解除一个阻塞的线程（和优先级无关），但是需要重新去获取锁，获取成功才能继续执行。  
如果想要使用对象的 `wait()` 和 `notify()`方法，必须先获取这个对象的锁，使用 `synchronized` 控制，不然会抛出 `IllegalMonitorStateException`。  
```java
synchronized (thread) {
    thread.notify();
}
```
***
Q：为什么你应该在循环中检查等待条件？  
A：处于等待的线程是可能收到错误警报或者伪唤醒( spurious wakeup )，如果不在循环中检查等待条件，程序有可能没有满足条件就推出了。  
```java
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```
***
Q：Thread类的sleep方法和对象自身的wait方法有什么区别？  
A：sleep 方法是线程 Thread 的静态方法，调用此方法会让当前线程暂停执行，将 CPU 让给其他线程，但是对象的锁依然保持，休眠时间结束后回到就绪状态。  
wait 方法是 Object 类的方法，调用`wait`方法，需要先获取这个对象的锁，然后当前线程会暂停执行，释放锁，进入这个对象的等待池(wait pool)。只有其他线程调用了这个对象的`notify`方法或者`notifyAll`方法时，才能唤醒进入等待锁池(lock pool)，如果重新获得了锁就可以进入就绪状态。
***
Q：notify 和 notifyAll 有什么区别？  
A：notify 只会随机唤醒一个在此对象等待池的线程，而 notifyAll 会唤醒这个对象等待池的所有线程。建议使用 notifyAll，防止 notify 因为信号丢失而造成程序错误。  
***
Q：为什么 wait、notify和notifyAll是Object类的方法，而不是Thread类的。  
A：因为 Java 提供的锁是对象级的锁，而不是线程级的锁。每个对象都有锁，通过线程来获取锁。
***
Q：Thread类的sleep、join、yield方法有什么区别？  
A：区别如下：
- sleep：静态方法，在指定的毫秒数内，让**当前**正在执行的线程休眠，不释放锁。
- yield：静态方法，让**当前**线程重新回到可执行状态，不释放锁。
- join：非静态方法，将**当前**线程 A 加入**另一个**线程 B 的尾部，在 B 执行完之前，A 不能执行。A 在等待状态不会释放锁。  
***










