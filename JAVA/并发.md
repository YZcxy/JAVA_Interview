# JAVA并发知识点

## Java线程

Q：程序、进程、线程的基本概念是什么？   
A：概念如下：
- 程序：包含指令和数据的文件，存储在磁盘或其他存储设备中，也就是说程序是静态的代码。  
- 进程：进程是操作系统运行程序的基本单位，当程序被执行时，会被操作系统载入到内存中，在计算机中一个指令一个指令的执行，同时占用着相关的CPU，内存，IO等资源，因此进程是动态的。  
- 线程：线程与进程类似，但是线程是更小的执行单位，一个进程可以在执行过程中产生多个线程。与进程不同，同类的多个线程共享同一块内存空间和系统资源，所以各个线程之间进行工作切换的负担很小。因此线程也被称为轻量级的进程。  
***
Q：守护线程是什么？  
A：任何线程都可以通过 `setDaemon()` 方法来设置是否为守护线程。守护线程是用来为其他线程服务的，JVM 会等待非守护线程执行完毕后才关闭，但是不会等待守护线程。JVM 的垃圾回收线程就是一个守护线程。  

***
Q：什么是多线程上下文切换？   
A：多线程会共同使用一组计算机上的CPU，而往往线程数是大于CPU数量的，为了让各个线程都有执行机会，就需要轮转使用CPU。  
在上下文切换过程中，CPU会停止处理当前运行的程序，保存好当前程序运行的具体位置后以便之后继续运行。页码信息会一直保存在CPU的内存中，直到再次被调用。  
***
Q：Java中用到的线程调度算法？  
A：操作系统中有四种调度算法，Java一般会使用两种调度模型：  
- 分时调度模型：让所有的线程轮流获得 CPU 的使用权，并且平均分配每个线程占用的时间片。  
- 抢占式调度模型：优先让可运行池中优先级高的线程占用 CPU，如果优先级相同就随机选择。处于运行状态的线程会一直运行。  
***
Q：什么是线程饥饿？  
A：一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。Java 中可能导致线程饥饿的原因有以下几点：  
- 高优先级线程吞噬所有低优先级线程的 CPU 时间。
- 线程被永久堵塞在一个等待进入同步块的状态。
- 线程在等待一个也处于等待的对象。
***
Q：线程的生命周期？  
A：线程一共有五种状态：  

- 新建(new)：当创建一个线程实例时，此线程就进入了新建状态。`Thread t = new Thread()`。  
- 可运行状态(runnable)：线程被调用了 start 方法时，该线程就进入可运行线程池中，等待线程调度选中，分配 CPU 的使用权。`t.start()`。  
- 运行状态(running)： 线程获得了 CPU 的使用权，正在执行任务( run 方法)。此时除非线程自动放弃了 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。  
- 死亡(dead)：当线程执行完或者被其他线程杀死，就进入了死亡状态。  
- 阻塞(blocked)：由于某种原因导致正在运行的线程让出了 CPU 资源并暂停执行，即进入了阻塞状态。有以下三种情况：  
  - `sleep()`：使当前线程进入睡眠，不释放锁。  
  - `wait()`：进入等待状态，等待 notify，释放锁。 
  - `suspend()`：进入等待状态，等待 resume，不释放锁，所以弃用了。  

![thread](http://static.iocoder.cn/04a277229fd3b24e058417f9c571681c)
***
Q：创建线程的方式？  
A：Java 中创建线程主要有三种方式：  
1. 继承 Thread 类。  
2. 实现 Runnable 接口。  
3. 通过 Callable 和 Future 结合。  
方式一方便简单，但是已经继承了 Thread 类，就无法继承其他类了。  
方式二和方式三通过实现接口，还可以继承其他类；**最重要**可以使用线程池执行任务。  
***
Q：start 和 run 方法有什么区别？  
A：`start()`方法会创建新的线程，执行 run 里面的代码。`run()`方法等于直接在当前线程调用 run，把 run 当做了一个普通的方法。  
***
Q：为什么 Thread 要废弃 stop 方法？  
A：因为调用 `stop()` 方法，会直接终止掉线程并且释放掉锁，线程内部是无法感知的。被突然的停止，可能就会导致有些工作没有完成，或者只完成了一半。  

***
Q：那么应该如何停止线程呢？  
A：一般来说，有两种方式：  
- 使用退出标志，这个 flag 变量要多线程可见。   
- 应该结合 `interrupt()` 和 `isInterrupted()` 使用。  
`interrupt()` 方法可以使一个被阻塞的线程抛出一个中断异常，可以捕获这个异常进行最后的收尾工作；如果线程没有被阻塞，也可以使用  `isInterrupted()` 来判断当前线程是否应该准备结束任务。   
***
Q：为什么不建议使用 suspend 和 resume 方法？  
A：suspend 和 resume 的作用是让一个线程暂停，但是线程不会释放锁。所以如果A线程使B线程暂停，A线程又依赖B线程的锁，那么就会造成死锁。  

***
Q：用什么方案替代 suspend 和 resume 呢？  
A：解决方案就是使用 `wait()` 和 `notify()` 方法实现线程阻塞。调用线程的 `wait()` 方法，线程会进入阻塞状态，并且释放锁；当调用 `notify()` 的时候会随机解除一个阻塞的线程（和优先级无关），但是需要重新去获取锁，获取成功才能继续执行。  
如果想要使用对象的 `wait()` 和 `notify()`方法，必须先获取这个对象的锁，使用 `synchronized` 控制，不然会抛出 `IllegalMonitorStateException`。  
```java
synchronized (thread) {
    thread.notify();
}
```
***
Q：为什么你应该在循环中检查等待条件？  
A：处于等待的线程是可能收到错误警报或者伪唤醒( spurious wakeup )，如果不在循环中检查等待条件，程序有可能没有满足条件就推出了。  
```java
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```
***
Q：Thread类的sleep方法和对象自身的wait方法有什么区别？  
A：sleep 方法是线程 Thread 的静态方法，调用此方法会让当前线程暂停执行，将 CPU 让给其他线程，但是对象的锁依然保持，休眠时间结束后回到就绪状态。  
wait 方法是 Object 类的方法，调用`wait`方法，需要先获取这个对象的锁，然后当前线程会暂停执行，释放锁，进入这个对象的等待池(wait pool)。只有其他线程调用了这个对象的`notify`方法或者`notifyAll`方法时，才能唤醒进入等待锁池(lock pool)，如果重新获得了锁就可以进入就绪状态。
***
Q：notify 和 notifyAll 有什么区别？  
A：notify 只会随机唤醒一个在此对象等待池的线程，而 notifyAll 会唤醒这个对象等待池的所有线程。建议使用 notifyAll，防止 notify 因为信号丢失而造成程序错误。  
***
Q：为什么 wait、notify和notifyAll是Object类的方法，而不是Thread类的。  
A：因为 Java 提供的锁是对象级的锁，而不是线程级的锁。每个对象都有锁，通过线程来获取锁。
***
Q：Thread类的sleep、join、yield方法有什么区别？  
A：区别如下：
- sleep：静态方法，在指定的毫秒数内，让**当前**正在执行的线程休眠，不释放锁。
- yield：静态方法，让**当前**线程重新回到可执行状态，不释放锁。
- join：非静态方法，将**当前**线程 A 加入**另一个**线程 B 的尾部，在 B 执行完之前，A 不能执行。A 在等待状态不会释放锁。  
***
Q：什么是 ThreadLocal 变量？  
A：每个线程都有一个`ThreadLocal`，也就是每个线程都拥有一个独立的变量，没有竞争条件。它是为创建代价高昂的对象获取线程安全的好方法。例如`SimpleDateFormat`对象，降低了这个对象的作为局部变量所产生的代价，并且提供了线程安全。  
***
Q：什么是 InheritableThreadLocal ？  
A：InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。  
***
Q：SimpleDateFormat 是线程安全的吗？  
A：不是，`DateFormat`的所有实现都不是线程安全的，因此建议`SimpleDateFormat`需要和`ThreadLocal`一起使用，不然在解析或者格式化日期时，可能获取不到正确时间。  
***
Q：哪些多线程开发良好的实践？  
A：如下实践都是值得学习的：  
- 给线程命名：方便找 bug 追踪。  
- 最小化同步范围：尽量使用最低限度的同步和锁，缩小临界区。  
- 优先尝试`volatile`，而不是`synchronized`。  
- 尽可能使用高层次的并发工具，而不是`wait`和`notify`。  
- 优先使用并发容器，而不是同步容器。  
- 考虑使用线程池。  
***
Q：什么是原子性？  
A：原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
***
Q：什么是可见性？  
A：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。当一个线程修改共享变量后他会立即被更新到主内存中；当其他线程读取共享变量时，它会直接从主内存中读取。  
***
Q：什么是有序性？  
A：有序性：即程序执行的顺序按照代码的先后顺序执行。在 Java 内存模型中，为了效率是允许编译器和处理器对指令进行重排序。重排序它不会影响单线程的运行结果，但是对多线程会有影响。
***

## Java 锁

Q：synchronized 是什么?  
A：synchronized 可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。  
***
Q：Java 中哪些对象可使用锁？  
A：Java 中每一个对象都可以实现锁：  
1. 普通同步方法，锁是当前的实例对象。
2. 静态同步方法，锁是当前类的 class 对象。
3. 同步方法块，锁是括号里面的对象。
***
Q：synchronized 是如何实现的？  
A：对于同步代码块和同步方法， 实现有所不同：  
- 同步代码块：使用`monitorenter`指令插入到同步代码块的开始位置，`monitorexit`指令插入到同步代码块的结束位置。任何对象都有一个 Monitor 与之相关联，当一个 Monitor 被持有之后，他将处于锁定状态。  
- 同步方法：`synchronized`方法则会被翻译成普通的方法调用和返回指令如：`invokevirtual`、`areturn`指令，在 VM 字节码层面并没有任何特别的指令来实现被`synchronized`修饰的方法，而是在 Class 文件的方法表中将该方法的`access_flags`字段中的`synchronized`标志位置设置为 1，表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示`Klass`作为锁对象。  
***
Q：什么是Java对象头？  
A：Java 对象头和 Monitor 是实现 `synchronized` 的基础，`synchronized` 用的锁是存在 Java 对象头中的。Hotspot 虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。  
- Klass Point 是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- Mark Word 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。  
***
Q：什么是 Monitor？  
A：Monitor 可以理解为是一个同步工具或者同步机制，它有如下特点：  
- 互斥：一个 Monitor 锁在同一时刻只能被一个线程占用，其他线程无法占用。
- 信号机制( signal )： 占用 Monitor 锁失败的线程会暂时放弃竞争并等待某个谓词成真（条件变量），但该条件成立后，当前线程会通过释放锁通知正在等待这个条件变量的其他线程，让其可以重新竞争锁。
***
Q：`synchronized` 为什么被称为重量级锁？  
A：在 JVM 中 `monitorenter` 和 `monitorexit` 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。然而，在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境），如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。  
***
Q：同步方法和同步代码块，谁更好？  
A：同步代码块更好，因为同步方法的锁是整个对象，当一个方法被锁，其他使用了`synchronized`关键字的方法也不能被访问。而同步代码块锁定范围更小，更符合**开放调用**的原则。  
***
Q：什么是死锁和活锁？  
A：死锁就是悲观锁可能导致的，活锁是乐观锁可能导致的。  
- 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
- 活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
***
Q：什么是悲观锁和乐观锁？  
A：区别如下：  
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。  
  例如传统关系型数据库中的行锁、表锁等，再比如`synchronized`关键字。  
- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。  
  例如`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁。  
***
Q：乐观锁的实现方式？  
A：使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。  
***
Q：为什么需要自旋锁？  
A：线程的阻塞和唤醒，**需要 CPU 从用户态转为核心态**。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时，我们发现在许多应用上面，**对象锁的锁状态只会持续很短一段时间**。为了这一段很短的时间，频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。
***
Q：什么是自旋锁？  
A：所谓的自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。  
如何等待呢，？执行一段无意义的循环即可。  
等待的时间呢？默认10次，可以使用`-XX:PreBlockSpin`调整。  
***
Q：什么是适应自旋锁？  
A：我们不难得出自选的次数其实很难人为判断，因为各种场景不同，等待时间也不同。因此就引入了适应自旋锁，它的旋转次数是由前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定的。  
- 如果上一次自旋成功，那么认为这一次也大可能成功，所以允许多自旋一会。
- 如果对于某个锁，多次自旋都失败，那么以后需要减少自旋次数或者省略掉自旋。
***
Q：什么是锁消除？  
A：如果 JVM 检测到某些数据不存在竞争，为了节省无意义的请求锁，会进行锁消除。那么如何才能判断是否有竞争呢。一般采取**逃逸分析**法。检测某些变量有没有逃逸出某个方法，如果没有逃逸出，只能是局部变量，那么就不需要加锁。  
```java
public void vectorTest(){
    Vector<String> vector = new Vector<String>();
    for (int i = 0 ; i < 10 ; i++){
    	vector.add(i + "");
    }
    System.out.println(vector);
}
```
例如以上代码的`vector`没有逃逸出`vectorTest`，那么内部操作就不需要加锁。  
***
Q：什么是锁粗化？  
A：我们知道在使用同步的时候会尽量缩小同步范围，但是如果一系列的连续加锁和解锁操作，可能会导致不必要的性能损耗。因此可以**将多个连续的加锁、解锁操作连接在一起**，扩展成一个更大范围的更大的锁。这就是锁粗化。  
***
Q：什么是锁升级？  
A：锁主要存在的四种状态分为为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。他们会随着竞争的激烈而逐渐升级。**锁可以升级但是不可以降级**。  
***
Q：什么是重量级锁？  
A：重量级锁就是通过对象内部的监视器 (Monitor) 实现的。依赖底层操作系统的 Mutex Lock 实现，需要在用户态和内核态之间切换，切换成本较高。例如`synchronize`。  
***
Q：什么是轻量级锁？  
A：引入轻量级锁的主要目的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。  

- 获取锁  
  1. 判断当前对象是否处于无锁状态？若是，则 JVM 首先将在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）；否则，执行步骤（3）；
  2. JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正。如果成功，表示竞争到锁，则将锁标志位变成 00（表示此对象处于轻量级锁状态），执行同步操作；如果失败，则执行步骤（3）；
  3. 判断当前对象的 Mark Word 是否指向当前线程的栈帧？如果是，则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志位变成 10，当前线程会被阻塞。
- 释放锁  
  1. 取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。
  2. 使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果成功，则说明释放锁成功；否则，执行（3）。
  3. 如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。
![qljs](http://static.iocoder.cn/4ad0dd09adc8e6826db5287b645a3436.jpg)
***
Q：什么是偏向锁？  
A：引入偏向锁主要目的是：为了在无多线程竞争的情况下，尽量减少不必要的轻量级锁执行路径。  
- 获取锁  
  1. 检测 Mark Word是 否为可偏向状态，即是否为偏向锁的标识位为 1 ，锁标识位为 01 。
  2. 若为可偏向状态，则测试线程 ID 是否为当前线程 ID ？如果是，则执行步骤（5）；否则，执行步骤（3）。
  3. 如果线程 ID 不为当前线程 ID ，则通过 CAS 操作竞争锁。竞争成功，则将 Mark Word 的线程 ID 替换为当前线程 ID ，则执行步骤（5）；否则，执行线程（4）。
  4. 通过 CAS 竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。
  5. 执行同步代码块
- 释放锁  
  偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。
![pxs](http://static.iocoder.cn/a134e56b39eb5450548e3f2aa1832459.jpg)
***
Q：三种锁之间的区别和转换？  
A：区别如下：  
![qubie](http://static.iocoder.cn/3c3d9fa58a474d6f3bf0cac00856c049.jpg)
![zh](http://static.iocoder.cn/cnblogs/9EB59781-D801-4922-90CA-C6D34944BB0C.png)
***
Q：volatile 有什么用？  
A：`volatile`保证内存可见性和禁止指令重排。同时可以提供部分原子性。  
- volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。
- 某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低 32 位和高 32 位)，但 volatile 类型的 double 和 long 就是原子的。不过需要在 64 位的 JVM 虚拟机上。
***
Q：volatile 变量和 atomic 变量有什么不同？  
A：区别如下：  
- `volatile` 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 `volatile` 修饰 `count` 变量，那么 `count++` 操作就不是原子性的。  
- `AtomicInteger` 类提供的 `atomic` 方法，可以让这种操作具有原子性。例如 `getAndIncrement()` 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。  
***
Q：可以创建 volatile 数组吗?  
A：可以修饰，但是指向的是数组的引用，而不针对于数组中的元素。因此多线程同时对数组中元素进行修改，是不具备保护作用的。Java 的 POJO 类同理。  
***
Q：volatile 和 synchronized 的区别？
A：区别如下：  
1. volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。  
2. synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。  
3. volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。  
4. volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。  
5. volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。  
6. volatile 标记的变量不会被编译器优化。synchronized 标记的变量可以被编译器优化。  
***
Q：什么场景下可以使用 volatile 替换 synchronized ？
A：有如下情景：  
1. 只需要保证共享资源的可见性的时候可以使用 volatile 替代，synchronized 保证可操作的原子性一致性和可见性。
2. volatile 适用于新值不依赖于旧值的情形。
3. 1 写 N 读场景。
4. 不与其他变量构成不变性条件时候使用 volatile 。
***
Q：什么是happens-before原则？  
A：有如下规则：  
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作，happens-before 于书写在后面的操作。
- 锁定规则：一个 unLock 操作，happens-before 于后面对同一个锁的 lock 操作。
- volatile 变量规则：对一个变量的写操作，happens-before 于后面对这个变量的读操作。
- 传递规则：如果操作 A happens-before 操作 B，而操作 B happens-before 操作C，则可以得出，操作 A happens-before 操作C
- 线程启动规则：Thread 对象的 start 方法，happens-before 此线程的每个一个动作。
- 线程中断规则：对线程 interrupt 方法的调用，happens-before 被中断线程的代码检测到中断事件的发生。
- 线程终结规则：线程中所有的操作，都 happens-before 线程的终止检测，我们可以通过Thread.join() 方法结束、Thread.isAlive() 的返回值手段，检测到线程已经终止执行。
- 对象终结规则：一个对象的初始化完成，happens-before 它的 finalize() 方法的开始。
***
Q：JVM 如何实现happen-before？  
A：观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入volatile 关键字时，会多出一个 lock 前缀指令。lock 前缀指令，其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile 的底层就是通过内存屏障来实现的。下图是完成上述规则所需要的内存屏障：  
![hb](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/201812082004.png)








