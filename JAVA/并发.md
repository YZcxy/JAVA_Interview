# JAVA并发知识点

Q：程序、进程、线程的基本概念是什么？   
A：概念如下：
- 程序：包含指令和数据的文件，存储在磁盘或其他存储设备中，也就是说程序是静态的代码。  
- 进程：进程是操作系统运行程序的基本单位，当程序被执行时，会被操作系统载入到内存中，在计算机中一个指令一个指令的执行，同时占用着相关的CPU，内存，IO等资源，因此进程是动态的。  
- 线程：线程与进程类似，但是线程是更小的执行单位，一个进程可以在执行过程中产生多个线程。与进程不同，同类的多个线程共享同一块内存空间和系统资源，所以各个线程之间进行工作切换的负担很小。因此线程也被称为轻量级的进程。  
***
Q：守护线程是什么？  
A：任何线程都可以通过 `setDaemon()` 方法来设置是否为守护线程。守护线程是用来为其他线程服务的，JVM 会等待非守护线程执行完毕后才关闭，但是不会等待守护线程。JVM 的垃圾回收线程就是一个守护线程。  
***
Q：什么是多线程上下文切换？   
A：多线程会共同使用一组计算机上的CPU，而往往线程数是大于CPU数量的，为了让各个线程都有执行机会，就需要轮转使用CPU。  
***
Q：线程的生命周期？  
A：线程一共有五种状态：  

- 新建(new)：当创建一个线程实例时，此线程就进入了新建状态。`Thread t = new Thread()`。  
- 可运行状态(runnable)：线程被调用了 start 方法时，该线程就进入可运行线程池中，等待线程调度选中，分配 CPU 的使用权。`t.start()`。  
- 运行状态(running)： 线程获得了 CPU 的使用权，正在执行任务( run 方法)。此时除非线程自动放弃了 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。  
- 死亡(dead)：当线程执行完或者被其他线程杀死，就进入了死亡状态。  
- 阻塞(blocked)：由于某种原因导致正在运行的线程让出了 CPU 资源并暂停执行，即进入了阻塞状态。有以下三种情况：  
  - `sleep()`：使当前线程进入睡眠，不释放锁。  
  - `wait()`：进入等待状态，等待 notify，释放锁。 
  - `suspend()`：进入等待状态，等待 resume，不释放锁，所以弃用了。  

![thread](http://static.iocoder.cn/04a277229fd3b24e058417f9c571681c)
***
Q：创建线程的方式？  
A：Java 中创建线程主要有三种方式：  
1. 继承 Thread 类。  
2. 实现 Runnable 接口。  
3. 通过 Callable 和 Future 结合。  
方式一方便简单，但是已经继承了 Thread 类，就无法继承其他类了。  
方式二和方式三通过实现接口，还可以继承其他类；**最重要**可以使用线程池执行任务。  
***
Q：start 和 run 方法有什么区别？  
A：`start()`方法会创建新的线程，执行 run 里面的代码。`run()`方法等于直接在当前线程调用 run，把 run 当做了一个普通的方法。  
***
Q：为什么 Thread 要废弃 stop 方法？  
A：因为调用 `stop()` 方法，会直接终止掉线程并且释放掉锁，线程内部是无法感知的。被突然的停止，可能就会导致有些工作没有完成，或者只完成了一半。  

***
Q：那么应该如何停止线程呢？  
A：一般来说，有两种方式：  
- 应该结合 `interrupt()` 和 `isInterrupted()` 使用。  
`interrupt()` 方法可以使一个被阻塞的线程抛出一个中断异常，可以捕获这个异常进行最后的收尾工作；如果线程没有被阻塞，也可以使用  `isInterrupted()` 来判断当前线程是否应该准备结束任务。 
- 使用退出标志，这个 flag 变量要多线程可见。  

***
Q：为什么不建议使用 suspend 和 resume 方法？  
A：suspend 和 resume 的作用是让一个线程暂停，但是线程不会释放锁。所以如果A线程使B线程暂停，A线程又依赖B线程的锁，那么就会造成死锁。  

***
Q：用什么方案替代 suspend 和 resume 呢？  
A：解决方案就是使用 `wait()` 和 `notify()` 方法实现线程阻塞。调用线程的 `wait()` 方法，线程会进入阻塞状态，并且释放锁；当调用 `notify()` 的时候会随机解除一个阻塞的线程（和优先级无关），但是需要重新去获取锁，获取成功才能继续执行。  
如果想要使用对象的 `wait()` 和 `notify()`方法，必须先获取这个对象的锁，使用 `synchronized` 控制，不然会抛出 `IllegalMonitorStateException`。  
```java
synchronized (thread) {
    thread.notify();
}
```
***
Q：为什么你应该在循环中检查等待条件？  
A：处于等待的线程是可能收到错误警报或者伪唤醒( spurious wakeup )，如果不在循环中检查等待条件，程序有可能没有满足条件就推出了。  
```java
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```
***
