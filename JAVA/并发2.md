Q：什么是原子操作？  
A：原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。   
- 处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。
- 在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。
***
Q：Java 提供了哪些原子类？  
A：如下：  
- 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 。
- 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 。
- 原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 。
- 解决 ABA 问题的原子类：AtomicMarkableReference，AtomicStampedReference。
***
Q：CAS 操作有什么缺点？
A：有以下三个缺点：  
1. ABA 问题：第一个线程读取了数据 A，第二个线程读取了数据 A，然后修改成 B 之后再修改回了 A，这时候第一个线程发现数据还是 A，觉得没问题，操作成功。  
2. 循环时间长：对于资源竞争严重的情况，CAS 自旋的概率比较大，浪费了很多 CPU 资源。效率低于 `synchronized`。
3. 只能保证一个共享变量的原子操作：CAS 只能保证一个共享变量的原子性，如果有有个共享变量，就只能用锁了。  
***
Q：Semaphore 是什么？  
A：Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，信号量维护了一个许可集合。  
- 如有必要，在许可可用前会阻塞每一个 #acquire() 方法，然后再获取该许可。
- 每个 #release() 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。
- 但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。
***
Q：CountDownLatch 原理是什么？  
A：CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。
***
Q：CyclicBarrier 原理是什么？  
A：CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。
***
Q：CyclicBarrier 和 CountdownLatch 有什么区别？  
A：CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。  

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为 0 时释放所有等待的线程                                | 计数达到指定值时释放所有等待线程                             |
| 计数为 0 时，无法重置                                        | 计数达到指定值时，计数置为 0 重新开始                        |
| 调用 `#countDown()` 方法计数减一，调用 `#await()` 方法只进行阻塞，对计数没任何影响 | 调用 `#await()` 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |

***
Q：什么是 Executor 框架？  
A：Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。  
***
Q：为什么使用 Executor 框架？  
A：有以下原因：  
1. 每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时、耗资源的。
2. 调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。
3. 接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。
***
Q：创建线程池的几种方式？  
A：Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。  
- 普通任务线程池
  1. `newFixedThreadPool(int nThreads)` 方法，创建一个固定长度的线程池。
每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。
  2. `newCachedThreadPool()` 方法，创建一个可缓存的线程池。
  3. `newSingleThreadExecutor()` 方法，创建一个单线程的线程池。
- 定时任务线程池
  1. `newScheduledThreadPool(int corePoolSize)` 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。
  2. `newSingleThreadExecutor()` 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。
***
Q：ThreadPoolExecutor 如何使用？  
A：Executors 提供了创建线程池的常用模板，实际场景下，我们可能需要自动以更灵活的线程池，此时就需要使用 ThreadPoolExecutor 类。  
- corePoolSize 参数，核心线程数大小，当线程数 < corePoolSize ，会创建线程执行任务。
- maximumPoolSize 参数，最大线程数， 当线程数 >= corePoolSize 的时候，会把任务放入 workQueue 队列中。
- keepAliveTime 参数，保持存活时间，当线程数大于 corePoolSize 的空闲线程能保持的最大时间。
- unit 参数，时间单位。
- workQueue 参数，保存任务的阻塞队列。
- handler 参数，超过阻塞队列的大小时，使用的拒绝策略。
- threadFactory 参数，创建线程的工厂。
***
Q：ThreadPoolExecutor 有哪些拒绝策略？  
A：默认有以下四个拒绝策略：  
- ThreadPoolExecutor.AbortPolicy() ，直接抛出异常 RejectedExecutionException 。
- ThreadPoolExecutor.CallerRunsPolicy() ，直接调用 run 方法并且阻塞执行。
- ThreadPoolExecutor.DiscardPolicy() ，直接丢弃后来的任务。
- ThreadPoolExecutor.DiscardOldestPolicy() ，丢弃在队列中队首的任务。
如果我们有需要，可以自己实现 `RejectedExecutionHandler` 接口，实现自定义的拒绝逻辑。
***
Q：线程池的关闭方式有几种？  
A：ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：  
- shutdown() 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。
- shutdownNow() 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。
***
Q：Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？  
A：一般说来，大家认为线程池的大小经验值应该这样设置：  
- 如果是 CPU 密集型应用，则线程池大小设置为 N+1
- 如果是 IO 密集型应用，则线程池大小设置为 2N+1
- 如果是混合型应用，那么分别创建线程池
***
Q：什么是 Callable、Future、FutureTask ？  
A：如下：  
1. Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。
2. Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。
3. 在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。
***
Q：线程池执行任务的过程？  
A：过程如下：  
1. 如果正在运行的线程数量小于核心参数 corePoolSize ，继续创建线程运行这个任务
  - 否则，如果正在运行的线程数量大于或等于 corePoolSize ，将任务加入到阻塞队列中。
  - 否则，如果队列已满，同时正在运行的线程数量小于核心参数 maximumPoolSize ，继续创建线程运行这个任务。
  - 否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize ，根据设置的拒绝策略处理。
2. 完成一个任务，继续取下一个任务处理。
  - 没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。
  - 否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 corePoolSize 。
***
Q：线程池中 submit 和 execute 方法有什么区别？  
A：两个方法都可以向线程池提交任务。execute 方法，返回类型是 void，submit 方法，可以返回持有计算结果的 Future 对象。
***
