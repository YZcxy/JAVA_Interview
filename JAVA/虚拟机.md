# JAVA虚拟机知识点

## JAVA虚拟机概述

Q：什么是Java虚拟机？  
A：Java 虚拟机是一个可以执行 JAVA 字节码(.class)的虚拟机进程。Java 源代码被编译成了 Java 虚拟机执行的字节码文件。  
***
Q：Java 代码如何做到跨平台运行？  
A：正是因为 Java 虚拟机的存在，JVM 是 C/C++ 开发，是编译后的机器码，不能跨平台，因此不同平台就需要不同版本的 JVM。简而言之，Java 源代码只需要编译成 JVM 能够识别的字节码，JVM 帮助程序屏蔽了各个计算机平台相关的差异，从而实现跨平台。  
![JVM](http://static.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301)  
***
Q：JVM 的基本结构？   
A：主要由4个部分组成：  
- 类加载器：在 JVM 启动时或者类运行时将需要的 class 加载到 JVM中。  
- 运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能。  
- 执行引擎：执行引擎负责执行 class 文件中包含的字节码指令。  
- 本地方法调用：调用 C 或者 C++ 实现的本地方法的代码返回结果。  
![structure](http://static.iocoder.cn/images/JDK/2020_02_10/01.jpg)  
***

## JVM运行时数据区

Q：JVM 运行时数据区的分类？  
A：主要分为5类:  
- 程序计数器：Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。  
  - 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。
- 虚拟机栈：Java 线程私有，虚拟机栈描述的是 Java 方法执行的内存模型。  
  - 每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。
- 本地方法栈：和 Java 虚拟机栈的作用类似，区别是该区域为 Native 方法服务。  
- 堆内存：线程共享，所有的线程共享的一块区域，垃圾收集器管理的主要区域。  
  - Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。
  - 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。
- 方法区：线程共享，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
  - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。
***
Q：什么是直接内存？  
A：直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。  

***
Q：Java 内存堆和栈区别？  
A：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。  

***
Q：为什么要废弃永久代？
A：由于字符串存放在永久代，永久代内存经常不够用或者内存泄漏，导致`java.lang.OutOfMemoryError: PermGen`。  
类及方法等信息比较难确认大小，对永久代的大小指定也比较困难。  
也会了融合HotSpot JVM 与 JRockit JVM 做准备。  

***
Q：JDK8 之后 Perm Space (永久代) 有哪些变动?  
A：有如下改动：  

- JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。  
- MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。  
- 可以通过 JVM 参数配置，`-XX:MetaspaceSize` 和 `-XX:MetaspaceSize`。  
***
Q：Java 内存堆和栈区别？  
A：有如下区别：  

- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 `java.lang.StackOverFlowError` 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 `java.lang.OutOfMemoryError` 错误。
- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。`-Xss` 选项设置栈内存的大小，`-Xms` 选项可以设置堆的开始时的大小。
***
Q：Jave对象创建的过程？  
A：Java 中对象的创建就是在堆上分配内存空间的过程，其中包括以下步骤：  

1. 检测类是否被加载  
当虚拟机遇到 `new` 指令时，首先 `new` 的参数是否在常量池中定位到一个类的**符号引用**。并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，则执行类加载过程。  
2. 为对象分配内存  
类加载完成之后，虚拟机就开始为对象分配内存。此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  
3. 为分配的内存空间初始化零值  
对象的内存分配完之后需要初始化为零值，这样能保证对象即使没有赋初始值也能够直接使用。  
4. 对对象进行其他设置  
比如设置这个对象所属的类，类的元数据信息，对象的 hashcode，GC分代等信息。这些信息都在对象头中。  
5. 执行 init 方法  
执行完以上步骤之后，虚拟机里对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成。因为此时这个对象还只是零值，需要 init 去赋予真正的初始值。  
![new](http://static.iocoder.cn/images/JDK/2020_02_10/07.png)  
***
Q：为对象分配内存时会遇到什么问题？  
A：具体分配内存时有两种情况：第一种是内存空间绝对规整，第二种情况是内存空间不连续。  
多线程并发时会出现正在给 A 分配内存时，还没来得及修改指针，对象 B 又用这个指针分配内存。针对以上两种分配情况有如下对应方案：  

- 面对第一种规整空间，采用同步的办法，使用 CAS 来保证操作的原子性。  
- 面对第二种空间不连续情况，是每个线程分配内存都在自己的空间内进行，即是每个线程在堆中预先分配了一小块内存，称为本地线程分配缓冲(TLAB)，分配内存在 TLAB 上分配，互不打扰。可以使用 `-XX:+/-UseTLAB` 设置大小。  
***
Q：对象的内存布局是怎样的？  
A：对象的内存布局包括三个部分：  
- 对象头：对象头包括存储对象自身的运行时数据，如哈希码、GC 分代，锁状态标志，线程持有锁等。还包括类型指针，即对象指向类元数据的指针。  
- 实例数据：就是具体的数据。
- 对齐填充：不是必然的存在。
***
Q：对象是如何定位访问的？  
A：对象的访问定位有两种：  
- 句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  
![jb](http://static.iocoder.cn/images/JDK/2020_02_10/04.png)  
- 直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。  
![zj](http://static.iocoder.cn/images/JDK/2020_02_10/05.png)  
***
Q：访问定位的两种方式的区别？  
A：他们各有优势，目前主流 HotSpot 使用的是直接指针访问。  
- 使用句柄的最大好处就是 reference 中存储的是稳定的句柄地址，在垃圾回收时可能会移动对象，这时只会改变句柄地址，而 reference 不会改变。  
- 使用直接指针的最大好处就是速度快，因为节省了一次指针定位的开销。  
***
Q：虚拟机有哪些常见的OutOfMemoryError异常？  
A：除了程序计数器之外，其他区域都可能有 OOM 异常。  
1. Java 堆溢出
2. 虚拟机栈和本地方法溢出
3. 运行时常量池溢出
4. 方法区的内存溢出
5. 云数据区的内存溢出
6. 本机直接内存溢出
***
Q：出现了内存溢出，如何排查错误？  
A：首先，控制台查看错误日志，然后可以使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。如果是堆内存溢出，查看是有创建了超大对象；如果是栈内存溢出，还需要排查是否产生了死循环。
***

## 垃圾回收器

Q：什么是垃圾回收机制？  
A：Java 中的对象是采用 `new` 或者反射来创建的，这些对象的创建都是在堆中分配的，所有的对象回收都是通过垃圾回收机制来完成的，GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。  
***
Q：为什么不建议显示使用 System.gc()？  
A：因为调用了 `System.gc()`，虚拟机不会立即就执行垃圾回收，由虚拟机自行决定执行时间。而且执行的是 Full GC，是需要停止所有的活动的，对应用存在很大的影响。  
***
Q：finalize 方法什么时候被调用?  
A：`finalize` 方法是在释放对象内存前由 GC 调用，通常可以在这个方法中释放该对象持有的资源，每个对象仅会被调用一次。  
***
Q：如何判断一个对象是否已经死去？  
A：有两种方式：  
- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数器 +1，释放一个引用时 -1，计数为0时表示可以回收。但是如果存在循环引用，就无法回收。  
- 可达性分析：从 GC Roots 开始向下搜索，搜索走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明对象不可达，可被回收。  
***
Q：哪些对象可以作为 GC Roots？  
A：有以下对象： 
1. 虚拟机栈中引用的对象。
2. 方法区中的类静态属性引用对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中 JNI 中引用的对象。
***
Q：方法区能否被回收？  
A：方法区可以被回收，但是价值很低，主要回收一些废弃的常量和**无用的类**。  
***
Q：如何判断方法区中无用的类？  
A：需要完全满足以下三个条件：  
1. 该类所有的实例都被回收
2. 该类加载器已经被回收
3. 该类对应的 Class 对象没有任何地方被引用，无法在任何地方利用反射访问。  
***
Q：Java中有哪些引用类型？  
A：Java 一共有四种引用类型：  
- 强引用：强引用是使用最多最普遍的引用，`new` 或者反射创建的都是强引用。如果一个对象具有强引用，那么垃圾回收就不会随意回收它。如果内存空间不足，即使抛出 OOM 异常，也不会随意回收强引用来解决内存不足问题。  
- 软引用：如果一个对象只有软引用，内存空间足够的话就不会回收，如果内存空间不足，就会回收软引用对象。因此软引用可以用来实现内存敏感的高速缓存。  
- 弱引用：弱引用是只要被垃圾回收器扫描到，就会被回收。不过因为垃圾回收是个优先级低的守护线程，不会经常执行，因为弱引用对象也有一定的生存时间。  
- 虚引用： 虚引用必须配合**引用队列**使用，当 GC 准备回收一个对象时，发现其还有虚引用，就会把这个虚引用加入到引用队列中，程序就可以通过判断引用队列，来采取一些必要的行动。  
***
Q：引用队列的作用？  
A：软/弱/虚引用都可以绑定一个引用队列，当这个引用的对象要被回收之前，会将这个引用加入到引用队列。
***
Q：为什么要有不同的引用类型？  
A：因为在 Java 中我们无法控制直接内存的申请和释放，有了不同的引用类型，可以稍微操控一下 GC 内存回收的时机。例如：  
- 利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题。  
- 通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person 的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person 对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。  
***
Q：JVM 垃圾回收算法有哪些？  
A：有四种算法：  
1. 标记-清除算法：标记-清除算法将垃圾回收分为两个阶段：**标记阶段和清除阶段**。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。但是缺点是标记和清除两个过程的效率都不高，并且会产生大量不连续的内存碎片，大量内存碎片会导致无法分配较大对象从而引起下一次 GC。
  ![](http://static.iocoder.cn/f07ac7c68994aa21b7b4271073ea4e5b)  
2. 标记-整理算法：标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。解决了内存碎片的问题，但是同样效率也不高。  
  ![](http://static.iocoder.cn/52ea9a3813e09621c563b1cd4bdf0d22)
3. 复制算法：复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。缺点就是浪费了一般的内存空间，并且如果对象存活较多，复制效率也会变低。  
  ![](http://static.iocoder.cn/cc3f228ca5353fd5deb4b22b7a9709e6)
4. 分代收集算法：当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。  
  - 在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。
  - 而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。
  ![](http://static.iocoder.cn/fec52af474f1250831d46b541e0fe7a9)
  - 图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。
  - 对象分配策略：
    - 对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。
    - 长时间存活的对象进入到 Old 区域。
  - 改进自复制算法
    - 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。
    - HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。
***
Q：什么是安全点？  
A：SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap 的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。
***
Q：JVM 垃圾收集器有哪些？  
A：如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。  
- 新生代收集器  
  - Serial 收集器，串行，复制算法，响应速度优先。  
  - ParNew 收集器，并行，复制算法，响应速度优先。
  - Parallel Scavenge 收集器，并行，复制算法，吞吐量优先。
- 老年代收集器
  - Serial Old 收集器，串行，标记整理算法，响应速度优先。
  - Parallel Old 收集器，并行，标记整理算法，吞吐量优先。
  - CMS 收集器，并发，标记清除算法，响应速度优先。
- 新生代 + 老年代收集器
  - G1 收集器，并发，标记整理+复制算法，响应速度优先。
  - ZGC 收集器。
***
Q：如何使用指定的垃圾收集器？  
A：配置如下：  

| 配置                   | 描述                                     |
| ---------------------- | ---------------------------------------- |
| -XX:+UserSerialGC      | 串行垃圾收集器                           |
| -XX:+UserParrallelGC   | 并行垃圾收集器                           |
| -XX:+UserParrallelGC   | 并发标记扫描垃圾回收器                   |
| -XX:ParallelCMSThreads | 并发标记扫描垃圾回收器 =为使用的线程数量 |
| -XX:+UseG1GC           | G1垃圾回收器                             |

***
Q：对象分配规则是什么？  
A：如下图所示：  
![](http://static.iocoder.cn/bc22a30cbe93b8dedda080144a73b613)
***
Q：为什么新生代内存需要有两个 Survivor 区？  
A：Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。设置两个 Survivor 区最大的好处就是解决了碎片化。永远有一个 survivor space 是空的，另一个非空的 survivor space 无碎片。  
***
Q：如何调整内存区域的比例？  
A：默认新生代(Young)与老年代(Old)的比例的值为 1:2 (该值可以通过参数 `–XX:NewRatio` 来指定)。默认的 Eden:from:to=8:1:1 (可以通过参数 `–XX:SurvivorRatio` 来设定)。
***
Q：什么情况下回出现 Full GC？  
A：Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。  
1. 在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。
2. 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。
3. 显式调用 `System.gc()` 方法时。
***
