# JAVA虚拟机知识点

## JAVA虚拟机概述

Q：什么是Java虚拟机？  
A：Java 虚拟机是一个可以执行 JAVA 字节码(.class)的虚拟机进程。Java 源代码被编译成了 Java 虚拟机执行的字节码文件。  
***
Q：Java 代码如何做到跨平台运行？  
A：正是因为 Java 虚拟机的存在，JVM 是 C/C++ 开发，是编译后的机器码，不能跨平台，因此不同平台就需要不同版本的 JVM。简而言之，Java 源代码只需要编译成 JVM 能够识别的字节码，JVM 帮助程序屏蔽了各个计算机平台相关的差异，从而实现跨平台。  
![JVM](http://static.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301)  
***
Q：JVM 的基本结构？   
A：主要由4个部分组成：  
- 类加载器：在 JVM 启动时或者类运行时将需要的 class 加载到 JVM中。  
- 运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能。  
- 执行引擎：执行引擎负责执行 class 文件中包含的字节码指令。  
- 本地方法调用：调用 C 或者 C++ 实现的本地方法的代码返回结果。  
![structure](http://static.iocoder.cn/images/JDK/2020_02_10/01.jpg)  
***

## JVM运行时数据区

Q：JVM 运行时数据区的分类？  
A：主要分为5类:  
- 程序计数器：Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。  
- 虚拟机栈：Java 线程私有，虚拟机栈描述的是 Java 方法执行的内存模型。  
- 本地方法栈：和 Java 虚拟机栈的作用类似，区别是该区域为 Native 方法服务。  
- 堆内存：线程共享，所有的线程共享的一块区域，垃圾收集器管理的主要区域。  
- 方法区：线程共享，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
***
Q：什么是直接内存？  
A：直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。  
***
Q：Java 内存堆和栈区别？  
A：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。  
***
Q：为什么要废弃永久代？
A：由于字符串存放在永久代，永久代内存经常不够用或者内存泄漏，导致`java.lang.OutOfMemoryError: PermGen`。  
类及方法等信息比较难确认大小，对永久代的大小指定也比较困难。  
也会了融合HotSpot JVM 与 JRockit JVM 做准备。  
***
Q：JDK8 之后 Perm Space (永久代) 有哪些变动?  
A：有如下改动：  
- JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。  
- MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。  
- 可以通过 JVM 参数配置，`-XX:MetaspaceSize` 和 `-XX:MetaspaceSize`。  
***
Q：Java 内存堆和栈区别？  
A：有如下区别：  
- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 `java.lang.StackOverFlowError` 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 `java.lang.OutOfMemoryError` 错误。
- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。`-Xss` 选项设置栈内存的大小，`-Xms` 选项可以设置堆的开始时的大小。
***
Q：Jave对象创建的过程？  
A：Java 中对象的创建就是在堆上分配内存空间的过程，其中包括以下步骤：  
1. 检测类是否被加载  
当虚拟机遇到 `new` 指令时，首先 `new` 的参数是否在常量池中定位到一个类的**符号引用**。并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，则执行类加载过程。  
2. 为对象分配内存  
类加载完成之后，虚拟机就开始为对象分配内存。此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  
3. 为分配的内存空间初始化零值  
对象的内存分配完之后需要初始化为零值，这样能保证对象即使没有赋初始值也能够直接使用。  
4. 对对象进行其他设置  
比如设置这个对象所属的类，类的元数据信息，对象的 hashcode，GC分代等信息。这些信息都在对象头中。  
5. 执行 init 方法  
执行完以上步骤之后，虚拟机里对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成。因为此时这个对象还只是零值，需要 init 去赋予真正的初始值。  
![new](http://static.iocoder.cn/images/JDK/2020_02_10/07.png)  
***
Q：为对象分配内存时会遇到什么问题？  
A：具体分配内存时有两种情况：第一种是内存空间绝对规整，第二种情况是内存空间不连续。  
多线程并发时会出现正在给 A 分配内存时，还没来得及修改指针，对象 B 又用这个指针分配内存。针对以上两种分配情况有如下对应方案：  
- 面对第一种规整空间，采用同步的办法，使用 CAS 来保证操作的原子性。  
- 面对第二种空间不连续情况，是每个线程分配内存都在自己的空间内进行，即是每个线程在堆中预先分配了一小块内存，称为本地线程分配缓冲(TLAB)，分配内存在 TLAB 上分配，互不打扰。可以使用 `-XX:+/-UseTLAB` 设置大小。  
***
Q：对象的内存布局是怎样的？  
A：对象的内存布局包括三个部分：  
- 对象头：对象头包括存储对象自身的运行时数据，如哈希码、GC 分代，锁状态标志，线程持有锁等。还包括类型指针，即对象指向类元数据的指针。  
- 实例数据：就是具体的数据。
- 对齐填充：不是必然的存在。
***
Q：对象是如何定位访问的？  
A：对象的访问定位有两种：  
- 句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  
![jb](http://static.iocoder.cn/images/JDK/2020_02_10/04.png)  
- 直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。  
![zj](http://static.iocoder.cn/images/JDK/2020_02_10/05.png)  
***
Q：访问定位的两种方式的区别？  
A：他们各有优势，目前主流 HotSpot 使用的是直接指针访问。  
- 使用句柄的最大好处就是 reference 中存储的是稳定的句柄地址，在垃圾回收时可能会移动对象，这时只会改变句柄地址，而 reference 不会改变。  
- 使用直接指针的最大好处就是速度快，因为节省了一次指针定位的开销。  
***
Q：虚拟机有哪些常见的OutOfMemoryError异常？  
A：除了程序计数器之外，其他区域都可能有 OOM 异常。  
1. Java 堆溢出
2. 虚拟机栈和本地方法溢出
3. 运行时常量池溢出
4. 方法区的内存溢出
5. 云数据区的内存溢出
6. 本机直接内存溢出
***
Q：出现了内存溢出，如何排查错误？  
A：首先，控制台查看错误日志，然后可以使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。如果是堆内存溢出，查看是有创建了超大对象；如果是栈内存溢出，还需要排查是否产生了死循环。
***

## 垃圾回收器

Q：什么是垃圾回收机制？  
A：Java 中的对象是采用 `new` 或者反射来创建的，这些对象的创建都是在堆中分配的，所有的对象回收都是通过垃圾回收机制来完成的，GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。  
***
Q：为什么不建议显示使用 System.gc()？  
A：因为调用了 `System.gc()`，虚拟机不会立即就执行垃圾回收，由虚拟机自行决定执行时间。而且执行的是 Full GC，是需要停止所有的活动的，对应用存在很大的影响。  
***
Q：finalize 方法什么时候被调用?  
A：`finalize` 方法是在释放对象内存前由 GC 调用，通常可以在这个方法中释放该对象持有的资源，每个对象仅会被调用一次。  
***
Q：如何判断一个对象是否已经死去？  
A：有两种方式：  
- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数器 +1，释放一个引用时 -1，计数为0时表示可以回收。但是如果存在循环引用，就无法回收。  
- 可达性分析：从 GC Roots 开始向下搜索，搜索走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明对象不可达，可被回收。  
***
Q：哪些对象可以作为 GC Roots？  
A：有以下对象： 
1. 虚拟机栈中引用的对象。
2. 方法区中的类静态属性引用对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中 JNI 中引用的对象。
***
Q：方法区能否被回收？  
A：方法区可以被回收，但是价值很低，主要回收一些废弃的常量和**无用的类**。  
***
Q：如何判断方法区中无用的类？  
A：需要完全满足以下三个条件：  
1. 该类所有的实例都被回收
2. 该类加载器已经被回收
3. 该类对应的 Class 对象没有任何地方被引用，无法在任何地方利用反射访问。  
***
Q：Java中有哪些引用类型？  
A：Java 一共有四种引用类型：  
- 强引用：强引用是使用最多最普遍的引用，`new` 或者反射创建的都是强引用。如果一个对象具有强引用，那么垃圾回收就不会随意回收它。如果内存空间不足，即使抛出 OOM 异常，也不会随意回收强引用来解决内存不足问题。  
- 软引用：如果一个对象只有软引用，内存空间足够的话就不会回收，如果内存空间不足，就会回收软引用对象。因此软引用可以用来实现内存敏感的高速缓存。  
- 弱引用：弱引用是只要被垃圾回收器扫描到，就会被回收。不过因为垃圾回收是个优先级低的守护线程，不会经常执行，因为弱引用对象也有一定的生存时间。  
- 虚引用： 虚引用必须配合**引用队列**使用，当 GC 准备回收一个对象时，发现其还有虚引用，就会把这个虚引用加入到引用队列中，程序就可以通过判断引用队列，来采取一些必要的行动。  
***
Q：引用队列的作用？  
A：软/弱/虚引用都可以绑定一个引用队列，当这个引用的对象要被回收之前，会将这个引用加入到引用队列。
***











