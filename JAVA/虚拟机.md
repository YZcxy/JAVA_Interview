# JAVA虚拟机知识点

## JAVA虚拟机概述

Q：什么是Java虚拟机？  
A：Java 虚拟机是一个可以执行 JAVA 字节码(.class)的虚拟机进程。Java 源代码被编译成了 Java 虚拟机执行的字节码文件。  
***
Q：Java 代码如何做到跨平台运行？  
A：正是因为 Java 虚拟机的存在，JVM 是 C/C++ 开发，是编译后的机器码，不能跨平台，因此不同平台就需要不同版本的 JVM。简而言之，Java 源代码只需要编译成 JVM 能够识别的字节码，JVM 帮助程序屏蔽了各个计算机平台相关的差异，从而实现跨平台。  
![JVM](http://static.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301)  
***
Q：JVM 的基本结构？   
A：主要由4个部分组成：  
- 类加载器：在 JVM 启动时或者类运行时将需要的 class 加载到 JVM中。  
- 运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能。  
- 执行引擎：执行引擎负责执行 class 文件中包含的字节码指令。  
- 本地方法调用：调用 C 或者 C++ 实现的本地方法的代码返回结果。  
![structure](http://static.iocoder.cn/images/JDK/2020_02_10/01.jpg)  
***

## JVM运行时数据区

Q：JVM 运行时数据区的分类？  
A：主要分为5类:  
- 程序计数器：Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。  
  - 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。
- 虚拟机栈：Java 线程私有，虚拟机栈描述的是 Java 方法执行的内存模型。  
  - 每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。
- 本地方法栈：和 Java 虚拟机栈的作用类似，区别是该区域为 Native 方法服务。  
- 堆内存：线程共享，所有的线程共享的一块区域，垃圾收集器管理的主要区域。  
  - Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。
  - 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。
- 方法区：线程共享，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
  - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。
***
Q：什么是直接内存？  
A：直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。  

***
Q：Java 内存堆和栈区别？  
A：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。  

***
Q：为什么要废弃永久代？
A：由于字符串存放在永久代，永久代内存经常不够用或者内存泄漏，导致`java.lang.OutOfMemoryError: PermGen`。  
类及方法等信息比较难确认大小，对永久代的大小指定也比较困难。  
也会了融合HotSpot JVM 与 JRockit JVM 做准备。  

***
Q：JDK8 之后 Perm Space (永久代) 有哪些变动?  
A：有如下改动：  

- JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。  
- MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。  
- 可以通过 JVM 参数配置，`-XX:MetaspaceSize` 和 `-XX:MetaspaceSize`。  
***
Q：Java 内存堆和栈区别？  
A：有如下区别：  

- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 `java.lang.StackOverFlowError` 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 `java.lang.OutOfMemoryError` 错误。
- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。`-Xss` 选项设置栈内存的大小，`-Xms` 选项可以设置堆的开始时的大小。
***
Q：Jave对象创建的过程？  
A：Java 中对象的创建就是在堆上分配内存空间的过程，其中包括以下步骤：  

1. 检测类是否被加载  
当虚拟机遇到 `new` 指令时，首先 `new` 的参数是否在常量池中定位到一个类的**符号引用**。并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，则执行类加载过程。  
2. 为对象分配内存  
类加载完成之后，虚拟机就开始为对象分配内存。此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  
3. 为分配的内存空间初始化零值  
对象的内存分配完之后需要初始化为零值，这样能保证对象即使没有赋初始值也能够直接使用。  
4. 对对象进行其他设置  
比如设置这个对象所属的类，类的元数据信息，对象的 hashcode，GC分代等信息。这些信息都在对象头中。  
5. 执行 init 方法  
执行完以上步骤之后，虚拟机里对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成。因为此时这个对象还只是零值，需要 init 去赋予真正的初始值。  
![new](http://static.iocoder.cn/images/JDK/2020_02_10/07.png)  
***
Q：为对象分配内存时会遇到什么问题？  
A：具体分配内存时有两种情况：第一种是内存空间绝对规整，第二种情况是内存空间不连续。  
多线程并发时会出现正在给 A 分配内存时，还没来得及修改指针，对象 B 又用这个指针分配内存。针对以上两种分配情况有如下对应方案：  

- 面对第一种规整空间，采用同步的办法，使用 CAS 来保证操作的原子性。  
- 面对第二种空间不连续情况，是每个线程分配内存都在自己的空间内进行，即是每个线程在堆中预先分配了一小块内存，称为本地线程分配缓冲(TLAB)，分配内存在 TLAB 上分配，互不打扰。可以使用 `-XX:+/-UseTLAB` 设置大小。  
***
Q：对象的内存布局是怎样的？  
A：对象的内存布局包括三个部分：  
- 对象头：对象头包括存储对象自身的运行时数据，如哈希码、GC 分代，锁状态标志，线程持有锁等。还包括类型指针，即对象指向类元数据的指针。  
- 实例数据：就是具体的数据。
- 对齐填充：不是必然的存在。
***
Q：对象是如何定位访问的？  
A：对象的访问定位有两种：  
- 句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  
![jb](http://static.iocoder.cn/images/JDK/2020_02_10/04.png)  
- 直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。  
![zj](http://static.iocoder.cn/images/JDK/2020_02_10/05.png)  
***
Q：访问定位的两种方式的区别？  
A：他们各有优势，目前主流 HotSpot 使用的是直接指针访问。  
- 使用句柄的最大好处就是 reference 中存储的是稳定的句柄地址，在垃圾回收时可能会移动对象，这时只会改变句柄地址，而 reference 不会改变。  
- 使用直接指针的最大好处就是速度快，因为节省了一次指针定位的开销。  
***
Q：虚拟机有哪些常见的OutOfMemoryError异常？  
A：除了程序计数器之外，其他区域都可能有 OOM 异常。  
1. Java 堆溢出
2. 虚拟机栈和本地方法溢出
3. 运行时常量池溢出
4. 方法区的内存溢出
5. 云数据区的内存溢出
6. 本机直接内存溢出
***
Q：出现了内存溢出，如何排查错误？  
A：首先，控制台查看错误日志，然后可以使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。如果是堆内存溢出，查看是有创建了超大对象；如果是栈内存溢出，还需要排查是否产生了死循环。
***

## 垃圾回收器

Q：什么是垃圾回收机制？  
A：Java 中的对象是采用 `new` 或者反射来创建的，这些对象的创建都是在堆中分配的，所有的对象回收都是通过垃圾回收机制来完成的，GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。  
***
Q：为什么不建议显示使用 System.gc()？  
A：因为调用了 `System.gc()`，虚拟机不会立即就执行垃圾回收，由虚拟机自行决定执行时间。而且执行的是 Full GC，是需要停止所有的活动的，对应用存在很大的影响。  
***
Q：finalize 方法什么时候被调用?  
A：`finalize` 方法是在释放对象内存前由 GC 调用，通常可以在这个方法中释放该对象持有的资源，每个对象仅会被调用一次。  
***
Q：如何判断一个对象是否已经死去？  
A：有两种方式：  
- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数器 +1，释放一个引用时 -1，计数为0时表示可以回收。但是如果存在循环引用，就无法回收。  
- 可达性分析：从 GC Roots 开始向下搜索，搜索走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明对象不可达，可被回收。  
***
Q：哪些对象可以作为 GC Roots？  
A：有以下对象： 
1. 虚拟机栈中引用的对象。
2. 方法区中的类静态属性引用对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中 JNI 中引用的对象。
***
Q：方法区能否被回收？  
A：方法区可以被回收，但是价值很低，主要回收一些废弃的常量和**无用的类**。  
***
Q：如何判断方法区中无用的类？  
A：需要完全满足以下三个条件：  
1. 该类所有的实例都被回收
2. 该类加载器已经被回收
3. 该类对应的 Class 对象没有任何地方被引用，无法在任何地方利用反射访问。  
***
Q：Java中有哪些引用类型？  
A：Java 一共有四种引用类型：  
- 强引用：强引用是使用最多最普遍的引用，`new` 或者反射创建的都是强引用。如果一个对象具有强引用，那么垃圾回收就不会随意回收它。如果内存空间不足，即使抛出 OOM 异常，也不会随意回收强引用来解决内存不足问题。  
- 软引用：如果一个对象只有软引用，内存空间足够的话就不会回收，如果内存空间不足，就会回收软引用对象。因此软引用可以用来实现内存敏感的高速缓存。  
- 弱引用：弱引用是只要被垃圾回收器扫描到，就会被回收。不过因为垃圾回收是个优先级低的守护线程，不会经常执行，因为弱引用对象也有一定的生存时间。  
- 虚引用： 虚引用必须配合**引用队列**使用，当 GC 准备回收一个对象时，发现其还有虚引用，就会把这个虚引用加入到引用队列中，程序就可以通过判断引用队列，来采取一些必要的行动。  
***
Q：引用队列的作用？  
A：软/弱/虚引用都可以绑定一个引用队列，当这个引用的对象要被回收之前，会将这个引用加入到引用队列。
***
Q：为什么要有不同的引用类型？  
A：因为在 Java 中我们无法控制直接内存的申请和释放，有了不同的引用类型，可以稍微操控一下 GC 内存回收的时机。例如：  
- 利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题。  
- 通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person 的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person 对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。  
***
Q：JVM 垃圾回收算法有哪些？  
A：有四种算法：  
1. 标记-清除算法：标记-清除算法将垃圾回收分为两个阶段：**标记阶段和清除阶段**。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。但是缺点是标记和清除两个过程的效率都不高，并且会产生大量不连续的内存碎片，大量内存碎片会导致无法分配较大对象从而引起下一次 GC。
  ![](http://static.iocoder.cn/f07ac7c68994aa21b7b4271073ea4e5b)  
2. 标记-整理算法：标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。解决了内存碎片的问题，但是同样效率也不高。  
  ![](http://static.iocoder.cn/52ea9a3813e09621c563b1cd4bdf0d22)
3. 复制算法：复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。缺点就是浪费了一般的内存空间，并且如果对象存活较多，复制效率也会变低。  
  ![](http://static.iocoder.cn/cc3f228ca5353fd5deb4b22b7a9709e6)
4. 分代收集算法：当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。  
  - 在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。
  - 而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。
  ![](http://static.iocoder.cn/fec52af474f1250831d46b541e0fe7a9)
  - 图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。
  - 对象分配策略：
    - 对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。
    - 长时间存活的对象进入到 Old 区域。
  - 改进自复制算法
    - 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。
    - HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。
***
Q：什么是安全点？  
A：SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap 的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。
***
Q：JVM 垃圾收集器有哪些？  
A：如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。  
- 新生代收集器  
  - Serial 收集器，串行，复制算法，响应速度优先。  
  - ParNew 收集器，并行，复制算法，响应速度优先。
  - Parallel Scavenge 收集器，并行，复制算法，吞吐量优先。
- 老年代收集器
  - Serial Old 收集器，串行，标记整理算法，响应速度优先。
  - Parallel Old 收集器，并行，标记整理算法，吞吐量优先。
  - CMS 收集器，并发，标记清除算法，响应速度优先。
- 新生代 + 老年代收集器
  - G1 收集器，并发，标记整理+复制算法，响应速度优先。
  - ZGC 收集器。
***
Q：如何使用指定的垃圾收集器？  
A：配置如下：  

| 配置                   | 描述                                     |
| ---------------------- | ---------------------------------------- |
| -XX:+UserSerialGC      | 串行垃圾收集器                           |
| -XX:+UserParrallelGC   | 并行垃圾收集器                           |
| -XX:+UserParrallelGC   | 并发标记扫描垃圾回收器                   |
| -XX:ParallelCMSThreads | 并发标记扫描垃圾回收器 =为使用的线程数量 |
| -XX:+UseG1GC           | G1垃圾回收器                             |

***
Q：对象分配规则是什么？  
A：如下图所示：  
![](http://static.iocoder.cn/bc22a30cbe93b8dedda080144a73b613)
***
Q：为什么新生代内存需要有两个 Survivor 区？  
A：Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。设置两个 Survivor 区最大的好处就是解决了碎片化。永远有一个 survivor space 是空的，另一个非空的 survivor space 无碎片。  
***
Q：如何调整内存区域的比例？  
A：默认新生代(Young)与老年代(Old)的比例的值为 1:2 (该值可以通过参数 `–XX:NewRatio` 来指定)。默认的 Eden:from:to=8:1:1 (可以通过参数 `–XX:SurvivorRatio` 来设定)。
***
Q：什么情况下回出现 Full GC？  
A：Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。  
1. 在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。
2. 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。
3. 显式调用 `System.gc()` 方法时。

***

## 类加载器

Q：类加载发生的时机是什么时候？  
A：虚拟机严格规定，有且仅有 5 种情况必须对类进行加载：  
1. 遇到 `new`、`getstatic`、`putstatic`、`invokestatic` 这四条字节码指令时，如果类还没进行初始化，则需要先触发其初始化。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类还没进行初始化，则需要先触发其初始化。
3. 当初始化了一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个执行的主类，即调用其 `main(String[] args)` 方法，虚拟机则会先初始化该主类。
5. 当使用 JDK7 的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果为 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic` 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
***
Q：类加载器是如何加载 Class 文件的？  
A：下图所示是 ClassLoader 加载一个 .class 文件到 JVM 时需要经过的步骤：  
![](http://static.iocoder.cn/images/JDK/2020_02_10/08.png)  
- 第一个阶段，加载(Loading)，是找到 .class 文件并把这个文件包含的字节码加载到内存中。
  - 在加载阶段，虚拟机需要完成以下三件事情：
    - 通过一个类的全限定名来获取其定义的二进制字节流。
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    - 在Java堆中生成一个代表这个类的 `java.lang.Class` 对象，作为对方法区中这些数据的访问入口。
  - 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。
- 第二阶段，连接(Linking)，又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配、最后的符号表的解析。
  - 验证：验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    - 文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以 `0xCAFEBABE` 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
    - 元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类，除了 `java.lang.Object` 之外。
    - 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
    - 符号引用验证：确保解析动作能正确执行。
  - 准备：准备阶段，是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。
    - 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
    - 这里所设置的初始值通常情况下是数据类型默认的零值(如 `0、0L、null、false` 等），而不是被在 Java 代码中被显式地赋予的值。
    - 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。
  - 解析：解析阶段，是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。
    - 符号引用，就是一组符号来描述目标，可以是任何字面量。
    - 直接引用，就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 第三阶段，Initialization(类中静态属性和初始化赋值)，以及Using(静态块的执行)等。
  - 初始化: 为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。
    - 假如这个类还没有被加载和连接，则程序先加载并连接该类。
    - 假如该类的直接父类还没有被初始化，则先初始化其直接父类。
    - 假如类中有初始化语句，则系统依次执行这些初始化语句。
***
Q：什么是双亲委派模型（Parent Delegation Model）？  
A：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，如下图所示：
![](http://static.iocoder.cn/images/JDK/2020_02_10/09.png)  
- Bootstrap ClassLoader ：根类加载器，负责加载 Java 的核心类，它不是 `java.lang.ClassLoader` 的子类，而是由 JVM 自身实现。  
- Extension ClassLoader ：扩展类加载器，扩展类加载器的加载路径是 JDK 目录下 `jre/lib/ext` 。扩展加载器的 `getParent()` 方法返回 null ，实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是 Java 实现的。
- System ClassLoader ：系统(应用)类加载器，它负责在 JVM 启动时加载来自 Java 命令的 `-classpath` 选项、`java.class.path` 系统属性或 CLASSPATH 环境变量所指定的 jar 包和类路径。程序可以通过 `getSystemClassLoader()` 来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径。
- 该模型要求除了顶层的 Bootstrap 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。简略代码如下：  
```java
// java.lang.ClassLoader
public abstract class ClassLoader {
    // The parent class loader for delegation
    // Note: VM hardcoded the offset of this field, thus all new fields
    // must be added *after* it.
    private final ClassLoader parent;
}
```
- 每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成）。
  - 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。
  - 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）。
  - 类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次。  

***
Q：Java 虚拟机是如何判定两个 Java 类是相同的？  
A：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。  
***
Q：双亲委派模型的工作过程？  
A：工作流程如下：  
1. 当前 ClassLoader 首先从自己已经加载的类中，查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。
2. 当前 ClassLoader 的缓存中没有找到被加载的类的时候
  - 委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。
  - 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。
***
Q：为什么优先使用父 ClassLoader 加载类？  
A：有以下两个原因：  
1. 共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。
2. 隔离功能：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException 。
```java
// java.lang.ClassLoader
// 删除部分无关代码
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 首先，从缓存中获得 name 对应的类
        Class<?> c = findLoadedClass(name);
        if (c == null) { // 获得不到
            try {
                // 其次，如果父类非空，使用它去加载类
                if (parent != null) {
                    c = parent.loadClass(name, false);
                // 其次，如果父类为空，使用 Bootstrap 去加载类
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            if (c == null) { // 还是加载不到
                // 最差，使用自己去加载类
                c = findClass(name);
            }
        }
        // 如果要解析类，则进行解析
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```
***
Q：什么是破坏双亲委托模型？  
A：破坏双亲委托模型，需要做的是，`loadClass(String name, boolean resolve)` 方法中，不调用父 parent ClassLoader 方法去加载类，那么就成功了。那么我们要做的仅仅是，错误的覆盖 `loadClass(String name, boolean resolve)` 方法，不去使用父 parent ClassLoader 方法去加载类即可。
***

## 虚拟机监控与调优

Q：JDK 的命令行工具有哪些可以监控虚拟机？  
A：有如下常用工具：  
- `jps` 虚拟机进程状况工具：JVM Process Status Tool ，显示指定系统内所有的HotSpot虚拟机进程。
- `jstat` 虚拟机统计信息监控工具：JVM statistics Monitoring ，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
- `jinfo` Java 配置信息工具：JVM Configuration info ，这个命令作用是实时查看和调整虚拟机运行参数。
- `jmap` Java 内存映射工具：JVM Memory Map ，命令用于生成 heap dump 文件。
- `jhat` 虚拟机堆转储快照分析工具：JVM Heap Analysis Tool ，命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型 的HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。
- `jstack` Java 堆栈跟踪工具：Java Stack Trace ，用于生成 Java 虚拟机当前时刻的线程快照。
- `HSDIS` ：JIT 生成代码反编译
***
Q：JDK 的可视化工具有哪些可以监控虚拟机？  
A：自带的有两款工具：  
- `JConsole` Java 监视与管理控制台：Java Monitoring and Management Console 是从 Java5 开始，在 JDK 中自带的 Java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控。
- `VisualVM` 多合一故障处理工具：JDK 自带全能工具，可以分析内存快照、线程快照、监控内存变化、GC变化等。特别是 BTrace 插件，动态跟踪分析工具。
***
Q：怎么获取 Java 程序使用的内存？  
A：可以通过 `java.lang.Runtime` 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。
- `Runtime.freeMemory()` 方法，返回剩余空间的字节数。
- `Runtime.totalMemory()` 方法，总内存的字节数。
- `Runtime.maxMemory()` 方法，返回最大内存的字节数。
***
Q：常见 GC 的优化配置？  
A：配置如下：  

| 配置              | 描述                                     |
| ----------------- | ---------------------------------------- |
| -Xms              | 初始化堆内存大小                         |
| -Xmx              | 堆内存最大值                             |
| -Xmn              | 新生代大小                               |
| -XX:PermSize      | 初始化永久代大小                         |
| -XX:MaxPermSize   | 永久代最大容量                           |
| -XX:SurvivorRatio | 设置年轻代中 Eden 区与 Survivor 区的比值 |
| -XX:Xmn           | 设置年轻代大小                           |

***
Q：Full GC的触发条件？  
A：大致如下：  
1. 程序执行了`System.gc()`，建议 jvm 执行 Full GC，并不一定会执行。
2. 执行了`jmap -histo:live pid`命令 ，这个会立即触发 Full GC。
3. 在执行 minor gc 的时候进行的一系列检查：  
  执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。  
如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。  
如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行 Full GC。  
如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行 Full GC。  
如果大于则会执行 Minor GC，如果Minor GC执行失败则会执行 Full GC。  
4. 使用了大对象 ，大对象会直接进入老年代。
5. 在程序中长期持有了对象的引用 ，对象年龄达到指定阈值也会进入老年代。
***
Q：如何排查线程 Full GC 频繁的问题？  
A：根据 Full GC 产生的大致原因，可以分析出大概率是使用了大对象，或者长期持有了对象的引用，老年代空间不足。可以通过 `Dump` 文件来分析堆内存的使用情况。  
***
Q：JVM 的永久代中会发生垃圾回收么？  
A：Young GC 不会发生在永久代。如果永久代满了或者是超过了临界值，会触发完全垃圾回收( Full GC )。如果我们仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。  
Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区。  
***

