# Mysql 知识点

Q：MySQL 中 varchar 与 char 的区别？  
A：区别如下：  
1. varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型。
2. varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 ORDER BY col 采用 fixed_length 计算 col 长度(memory引擎也一样)。
***
Q：一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？  
A：一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。  
但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。  
***
Q：表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?  
A：拆带来的问题：连接消耗 + 存储拆分空间。不拆可能带来的问题：查询性能。  
实际场景下，例如说商品表数据量比较大的情况下，会将商品描述单独存储到一个表中。即，使用拆的方案。
***
Q：MySQL 有哪些存储引擎？  
A：常用的是 InnoDB 和 MyISAM。  
- InnoDB
- MyISAM
- MRG_MYISAM
- MEMORY
- CSV
- ARCHIVE
- BLACKHOLE
- PERFORMANCE_SCHEMA
- FEDERATED
***
Q：为什么 MySQL 的默认引擎是 InnoDB？  
A：5.1之前默认是 MyISAM，由于不支持事务，使用表级锁，目前已经停止更新。InnoDB 的优点如下：  
- 【最重要】支持事务。
- 支持行级锁和表级锁，能支持更多的并发量。
- 查询不加锁，完全不影响查询。
- 支持崩溃后恢复。

***
Q：为什么 `SELECT COUNT(*) FROM table` 在 InnoDB 比 MyISAM 慢？  
A：在没有 `WHERE` 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。
***
Q：什么是索引？  
A：索引，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。
***
Q：索引有什么好处？  
A：优点如下：  
1. 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。
2. 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。
***
Q：索引有什么坏处？  
A：缺点如下：  
1. 占用额外的存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。
2. 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。
***
Q：索引的使用场景？  
A：不同场景有不同的用法：  
1. 对非常小的表，大部分情况下全表扫描效率更高。
2. 对中大型表，索引非常有效。
3. 特大型的表，建立和使用索引的代价随着增长，可以使用分区技术或者**分库分表**来解决。
***
Q：索引的类型有哪些？  
A：索引，都是实现在存储引擎层面的，主要有六种类型：  
1. 普通索引：最基本的索引，没有任何约束。
2. 唯一索引：与普通索引类似，但具有唯一性约束。
3. 主键索引：特殊的唯一索引，不允许有空值。
4. 复合索引：将多个列组合在一起创建索引，可以覆盖多个列。
5. 外键索引：只有 InnoDB 类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。
6. 全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。
***
Q：MySQL 索引的 创建 原则？  
A：有如下原则：  
1. 最适合索引的列是出现在 `WHERE` 子句中的列，或连接子句中的列，而不是出现在 `SELECT` 关键字后的列。
2. 索引列的基数越大，索引效果越好。
4. 避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。
5. 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。
6. 对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。
***
Q：MySQL 索引的使用注意事项？  
A：注意事项如下：  
1. 应尽量避免在 WHERE 子句中使用 `!=` 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。
2、应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：`SELECT id FROM t WHERE num = 10 OR num = 20` 。
3、应尽量避免在 WHERE 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
4、应尽量避免在 WHERE 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
5、不要在 WHERE 子句中的 = 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
6、复合索引遵循前缀原则。
7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。
8、列类型是字符串类型，查询时一定要给值加引号，否则索引失效。
9、LIKE 查询，% 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。
***
Q：什么是 B-Tree 索引？  
A：二叉查找树或其进化品种红黑树（red-black tree）都是可以增加查询效率的树形结构，B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块，减少磁盘的 I/O 次数。  
![](http://static.iocoder.cn/84ea509fa091a10add4e7614e6cb37db)
***
Q：什么是 B+Tree 索引？  
A：从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。  
![](http://static.iocoder.cn/259d196856a231aff5e3cf1505848af4)
***
Q：请说说 MySQL 的锁机制？  
A：表锁是日常开发中的常见问题，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。MySQL 的共享锁和排他锁，就是读锁和写锁。  
共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。  
排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。  
***
Q：什么是悲观锁？什么是乐观锁？  
A：定义如下：  
1. 悲观锁：悲观地认为我想要访问的数据一定会被其他人访问或者修改。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。  
2. 乐观锁：乐观地认为不会有人来修改我想要访问的数据，等真被其他人修改了再做 CAS 处理。 乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。   
***
Q：InnoDB 引擎的行锁是如何实现的？  
A：InnoDB 是基于索引来完成行锁。例如：`SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE` 。`FOR UPDATE` 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起。
***
Q：事务是如何通过日志来实现的？  
A：基本流程如下：  
- 因为事务在修改页时，要先记 undo ，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 redo（里面包括 undo 的修改）一定要比数据页先持久化到磁盘。
- 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态。
- 崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo 把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。








