# Redis 知识点

Q：什么是 Redis ？  
A：Redis ，全称 Remote Dictionary Server ，是一个基于内存的高性能 Key-Value 数据库。  
***
Q：Redis 有什么优点？  
A：优点如下：  
1. 速度快：因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。
2. 支持丰富数据类型：支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。同时，在基础的数据结构之上，还提供 Bitmap、HyperLogLog、GEO 等高级的数据结构。
3. 丰富的特性：订阅发布 Pub / Sub 功能，Key 过期策略，事务，支持多个 DB，计数。
4. 持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。
5. 高可用：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。
***
Q：Redis 的线程模型是怎样的？  
A：Redis 是**非阻塞 IO ，多路复用**。  
![](http://static.iocoder.cn/images/Redis/2019_11_22/01.png)
- 客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 `AE_READABLE` 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 Socket01，并将该 Socket01 的 AE_READABLE 事件与**命令请求处理器**关联。
- 此时客户端发送了一个 set key value 请求，此时 Redis 中的 Socket01 会产生 `AE_READABLE` 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 Socket01 的 `AE_READABLE` 事件已经与**命令请求处理器**关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Scket01 的 `set key value` 并在自己内存中完成 `set key value` 的设置。操作完成后，它会将 Scket01 的 `AE_WRITABLE` 事件与**命令回复处理器**关联。
- 此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的**命令回复处理器**，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 Socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。

***
Q：为什么 Redis 单线程模型也能效率这么高？  
A：原因如下：  
1. C语言实现。
2. 纯内存操作。
3. 非阻塞的 IO 多路复用机制。
4. 单线程，避免了多线程的频繁上下文切换问题。
5. 丰富的数据结构。
***
Q：Redis 是单线程的，如何提高多核 CPU 的利用率？  
A：可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU ，你可以考虑一下分区。  
***
Q：Redis 有几种持久化方式？  
A：Redis 提供了两种方式，实现数据的持久化到硬盘。  
- 【全量】RDB 持久化，是指在指定的时间间隔内将内存中的数据集快照写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用**二进制压缩存储**。  
- 【增量】AOF持久化，以**日志的形式**记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。
***
Q：RDB 优缺点？  
A：如下：

1. 优点
- 灵活设置备份频率和周期。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
- 非常适合冷备份，对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 OSS 分布式存储上。
- 性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是分出一个子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。
- 恢复更快。相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。
2. 缺点
- 如果你想保证数据的高可用性，即**最大限度的避免数据丢失**，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
- 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

***
Q：AOF 优缺点？  
A：如下：
1. 优点
- 该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了 3 种同步策略，即**每秒同步、每修改(执行一个命令)同步 和 不同步**。
  - 事实上，**每秒同步也是异步完成的**，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
  - 而每修改同步，我们可以将其视为**同步持久化**，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在**效率上是最低**的。
  - 至于不同步，无需多言，我想大家都能正确的理解它。
- 由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
  - 因为以 **append-only** 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。
  - 另外，如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 **redis-check-aof** 工具来帮助我们解决数据一致性的问题。
- 如果 AOF 日志过大，Redis 可以自动启用 **rewrite** 机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 **rewrite log** 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。
- AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。
2. 缺点
- 对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
- 根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。
- 以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。

***
Q：什么是RDB-AOF混合持久化？  
A：由于RDB 和 AOF 各有优缺点，因此 Redis 4.0之后允许RDB-AOF混合持久化，通过 `aof-use-rdb-preamble`配置项开启。  
***
Q：在实际环境中如何使用持久化？  
A：有如下点需要注意。  
- RDB 的 `bgsave` 用来做镜像全量持久化，AOF 做增量持久化。因为 `bgsave` 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 `bgsave` 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态，这个恢复过程也叫**RDB-AOF混合持久化**。  
- 那如果突然机器掉电会怎样？取决于 AOF 日志 `sync`同步策略属性的配置，如果不要求性能，在每条写指令时都 `sync` 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 `sync` 是不现实的，一般都使用定时 `sync` ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。  
- `bgsave` 的原理是什么？你给出两个词汇就可以了，`fork` 和 `cow` 。`fork` 是指 Redis 通过创建子进程来进行 `bgsave` 操作。`cow` 指的是 `copy on write` ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

***
Q：为什么不建议在主 Redis 节点开启 RDB 功能呢？  
A：主要原因如下：  
- 子进程 `fork` 相关的阻塞：在 `bgsave` 的时候，Redis 主进程会 `fork` 一个子进程，利用操作系统的**写时复制技术（copy on write）**，这个子进程在拷贝父进程的时候理论上是很快的，因为并不需要全拷贝，比如主进程虽然占了 10G 内存，但子进程拷贝他可能只要 200 毫秒，我认为也就阻塞了 200 毫秒(此耗时基本跟主进程占用的内存是成正比的)，这个具体的时间可以通过统计项 `info stats` 里的 `last_fork_use`c 查看。  
- CPU 单线程，主线程和 `fork` 子线程共享CPU。  
***
Q：Redis 有几种数据“过期”策略？  
A：过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。  
- 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
- 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
- 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。

***
Q：Redis 有哪几种数据“淘汰”策略？  
A：Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。Redis 提供了 6 种数据淘汰策略：  
1. volatile-lru：从已设置过期时间的数据集中挑选**最近最少使用**的数据淘汰。redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。  
2. volatile-ttl：从已设置过期时间的数据集中挑选**将要过期**的数据淘汰。redis 并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。  
3. volatile-random：从已设置过期时间的数据集中**任意选择**数据淘汰。当内存达到限制的时候无法写入非过期时间的数据集。  
4. allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对**所有数据集**挑选最近最少使用的数据淘汰，可写入新的数据集。  
5. allkeys-random：从数据集中任意选择数据淘汰，当内存达到限制的时候，对**所有数据集**挑选随机淘汰，可写入新的数据集。  
6. 【默认策略】no-enviction：当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。  

Redis 4.0 之后，新增了两种 LFU（Least Frequently Used）策略：  
1. volatile-lfu
2. allkeys-lfu

***
Q：Redis 回收进程如何工作的？  
A：过程如下：  
- 一个客户端运行了新的写命令，添加了新的数据。
- Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。
- Redis 执行新命令。

***
Q：如果有大量的 key 需要设置同一时间过期，一般需要注意什么？  
A：如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。  
***
Q：Redis 有哪些数据结构？  
A：如下：  
如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：
- 字符串 String
- 字典Hash
- 列表List
- 集合Set
- 有序集合 SortedSet

如果你是 Redis 中级玩家，还需要加上下面几种数据结构：
- HyperLogLog
- Geo
- Bitmap

如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：
- BloomFilter
- RedisSearch
- Redis-ML
- JSON

***
Q：Redis 使用场景有哪些？  
A：Redis的可用场景非常多：  
- 数据缓存
- 会话缓存
- 时效性数据
- 访问频率
- 计数器
- 社交列表
- 记录用户判定信息
- 交集、并集和差集
- 热门列表与排行榜
- 最新动态
- 消息队列
- 分布式锁

***
Q：如何使用 Redis 实现分布式锁？  
A：Redis 实现分布式锁，需要考虑如下几个方面：  
1. 正确的获得锁：set 指令附带 nx 参数，保证有且只有一个进程获得到。
2. 正确的释放锁：使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放。
3. 超时的自动释放锁：set 指令附带 expire 参数，通过过期机制来实现超时释放。
4. 未获得到锁的等待机制：sleep 或者基于 Redis 的订阅 Pub/Sub 机制。
5. 【可选】锁的重入性：通过 ThreadLocal 记录是第几次获得相同的锁。有且第一次计数为 1 ，才向 Redis 发起获得锁的操作。有且计数为 0 ，才向 Redis 发起释放锁的操作。  
6. 锁超时的处理：一般情况下，可以考虑告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证有且仅有一个线程，正在持有锁。
7. Redis 分布式锁丢失问题：Redlock。

***
Q：什么是 Redlock 方式实现分布式锁？  
A：`set` 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。因此需要更高级的 Redlock 。
***
Q：如何使用 Redis 实现消息队列？  
A：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。blpop 可以实现阻塞代替 sleep，pub / sub 可以实现多次消费，但是没有消费者消息会丢失，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。  
***
Q：什么是 Redis 事务？  
A：在 Redis 中，`MULTI / EXEC / DISCARD / WATCH` 这四个命令是我们实现事务的基石。  
1. 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。  
2. 和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。  
3. 我们可以通过 `MULTI` 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 `"BEGIN TRANSACTION"` 语句。在该语句之后执行的命令，都将被视为事务之内的操作，最后我们可以通过执行 `EXEC / DISCARD` 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 `COMMIT / ROLLBACK` 语句。  
4. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。  

***
Q：如何实现 Redis CAS 操作？  
A：在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set) 功能。  
假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 nil 应答以通知调用者事务执行失败。  
***
Q：Redis 集群都有哪些方案？  
A：Redis 集群方案如下：  
1. Redis Sentinel
2. Redis Cluster
3. Twemproxy
4. Codis
5. 客户端分片

***
Q：Redis 为什么需要集群？  
A：单个节点的缓存容量会达到上限，单个节点的 QPS（每秒查询个数）也会达到上限。因此需要扩容节点。扩容节点后会带来一些问题，例如：  
- 如何保证缓存数据的均匀，不要只集中在一台节点。
- 如何进行数据之间的同步。
- 当某台节点挂掉之后，怎么使服务影响最小。


***
Q： 如何保证缓存数据的均匀？  
A：为了让缓存均匀分布，最初步的方案就是将 hash 值取模运算`hash(key) % N`，但是这样做，一旦节点挂掉变为N-1，或者扩容节点变为N+1，就会导致大规模hash失效。因此提出了一致性哈希算法。  
一致性哈希将整个哈希值空间组织成一个虚拟的圆环。  
下一步将各个服务器使用 Hash 进行一个哈希，这样每台机器就能确定其在哈希环上的位置。  
接下来将数据key使用相同的函数 Hash 计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。  
![](https://img-blog.csdnimg.cn/20200412111238951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjc4NDk1MQ==,size_16,color_FFFFFF,t_70)  
如此一来，无论是新增节点，还是删除节点，都只会影响当前节点的缓存，不会影响所有节点。

***
Q：如何选择集群方案？  
A：体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。  

***
Q：什么是 Redis 主从同步？  
A：Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过**网络传输**拷贝到完整的**数据备份**，从而达到主从机制。  

- 主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而**从数据库一般是只读的**，并接收主数据库同步过来的数据。
- 一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。
- 第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

***
Q：什么是 Redis 哈希槽的概念？  
A：Redis Cluster 没有使用**一致性 hash **，而是引入了**哈希槽**的概念。Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。  
为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。  
***
Q：有哪些 Redis 分区实现方案？  
A：主要分为两种类型：  
- 客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。
  - 案例：Redis Cluster 和客户端分区。
- 代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。
  - 案例：Twemproxy 和 Codis 。

***









