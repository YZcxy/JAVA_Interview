# HTTP 协议知识点

Q：HTTP 是什么？  
A：HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。主要特点如下：  
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- 数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
- 支持 B/S 及 C/S 模式。
***
Q：HTTP 请求格式？  
A：如下图所示：  
![](http://static.iocoder.cn/e0f66085155bdcdaa170fab4507fa4f1)
- 请求行：用来说明请求类型，要访问的资源以及所使用的 HTTP 版本。
- 请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。
  - HOST ，将指出请求的目的地。
  - User-Agent ，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等
- 空行：请求头部后面的空行是必须的。
- 请求数据：也叫主体，可以添加任意的其他数据。
***
Q：HTTP 响应格式？  
A：如下图所示：  
![](http://static.iocoder.cn/da1ada597b5feedcd7d6c17d1989629d)
- 状态行：由 HTTP 协议版本号、状态码、状态消息三部分组成。
- 消息报头：用来说明客户端要使用的一些附加信息。
- 空行：消息报头后面的空行是必须的。
- 响应正文：服务器返回给客户端的文本信息。
***
Q：HTTP 协议包括哪些请求？  
A：有如下8种类型：  
1. GET: 对服务器资源的简单请求。
2. POST: 用于发送包含用户提交数据的请求。
3. HEAD：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头。
4. PUT：传说中请求文档的一个版本。
5. DELETE：发出一个删除指定文档的请求。
6. TRACE：发送一个请求副本，以跟踪其处理进程。
7. OPTIONS：返回所有可用的方法，检查服务器支持哪些方法。
8. CONNECT：用于 SSL 隧道的基于代理的请求。
***
Q：GET 和 POST 的区别？  
A：区别如下：  

| 请求方式 | 数据位置         | 明文密文 | 数据安全 | 长度限制         | 应用场景 |
| -------- | ---------------- | -------- | -------- | ---------------- | -------- |
| GET      | HTTP请求的path中 | 明文     | 不安全   | 长度较小，一般2k | 查询数据 |
| POST     | HTTP请求body中   | 可明可密 | 安全     | 支持较大数据传输 | 修改数据 |
- 对于 GET 方式的请求，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）。
而对于 POST，浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）。
***
Q：HTTP 有哪些状态码？  
A：如下：  
- 1×× : 请求处理中，请求已被接受，正在处理
- 2×× : 请求成功，请求被成功处理
  - 200 OK // 客户端请求成功
- 3×× : 重定向，要完成请求必须进行进一步处理
  - 301 Moved Permanently // 永久重定向,使用域名跳转
  - 302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面
- 4×× : 客户端错误，请求不合法
  - 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
  - 403 Forbidden // 服务器收到请求，但是拒绝提供服务
  - 404 Not Found // 请求资源不存在，eg：输入了错误的 URL
5×× : 服务器端错误，服务器不能处理合法请求
  - 500 Internal Server Error // 服务器发生不可预期的错误
  - 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常
***
Q：forward 和 redirect 的区别？  
A：区别如下：  
- 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。
- 间接转发方式（Redirect），实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。
***
Q：HTTP、TCP、Socket 的关系是什么？  
A：关系如下：  
- TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。
- HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。
- Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。  

综上所述：  

- 需要 IP 协议来连接网络
- TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。
- HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。
***
Q：Cookies 和 Session 的区别？  
A：区别如下：  
- Session 在服务器端，Cookie 在客户端（浏览器）。
- Session 默认被存在在服务器的一个文件里（不是内存）。
- Session 的运行依赖 sessionid ，而 sessionid 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 session 也会失效。但是，可以通过其它方式实现，比如在 url 参数中传递 sessionid 。
- Session 可以放在文件、数据库、或内存中都可以。
- 【关键】用户验证这种场合一般会用 Session 。
***
Q：一次完整的 HTTP 请求所经历的步骤？  
A：步骤如下：  
1. DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。
2. HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。
3. 客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。
4. 客户端发送请求头信息和数据。
5. 服务器发送应答头信息。
6. 服务器向客户端发送数据。
7. 服务器关闭 TCP 连接（4次挥手）。
8. 客户端根据返回的 HTML、CSS、JS 进行渲染。
***
Q：HTTP1.0 和 HTTP1.1 有什么区别？  
A：主要是如下 8 点：  
1. 可扩展性
2. 缓存
3. 带宽优化
4. 长连接
5. 消息传递
6. Host 头域
7. 错误提示
8. 内容协商
***
Q：什么是支持长连接？  
A：处理在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1中 默认开启 `Connection：keep-alive`。  
***
Q：什么是请求的流水线？  
A：HTTP1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。  
***
Q：HTTPS 是什么？  
A：HTTPS ，实际就是在 TCP 层与 HTTP 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。  
HTTP + 加密 + 认证 + 完整性保护 = HTTPS 。  
![](http://static.iocoder.cn/a9e8780d6b899cf5709579fc9c451fd9)
***
Q：什么是 SSL 呢？什么是 TLS 呢？  
A：官方定义，SSL 是安全套接层(secure sockets layer)；TLS 是 SSL 的继任者，叫传输层安全(transport layer security)。  
它们存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。  
- SSL1.0: 已废除
- SSL2.0: RFC6176 ，已废除
- SSL3.0: RFC6101 ，基本废除
- TLS1.0: RFC2246 ，目前大都采用此种方式
- TLS1.1: RFC4346
- TLS1.2: RFC5246 ，没有广泛使用
- TLS1.3: IETF 正在酝酿中
***
Q：SSL/TLS 协议作用？  
A：作用如下：  
1. 认证用户和服务器，确保数据发送到正确的客户机和服务器。
2. 加密数据以防止数据中途被窃取。
3. 维护数据的完整性，确保数据在传输过程中不被改变。
***
Q：HTTP 和 HTTPS 的区别？  
A：区别如下：  
- 端口不同：HTTP 与 HTTPS 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- 资源消耗：和 HTTP 通信相比，HTTPS 通信会由于加解密处理消耗更多的 CPU 和内存资源。
- 开销：HTTPS 通信需要证书，而证书一般需要向认证机构申请免费或者付费购买。
***
Q：SSL 加密方式是什么？  
A：加密分为两大类：  
- 对称密钥加密，是指加密和解密使用同一个密钥的方式，效率比非对称加密快，但是这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。
- 非对称加密，指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
SSL首先使用非对称加密，将对称加密的秘钥安全的传输给对方，然后双方就可以安全的使用对称加密了。  
***
Q：什么是单向认证、双向认证？  
A：如下：  
- 单向认证，指的是只有一个对象校验对端的证书合法性。通常都是 Client 来校验服务器的合法性。那么 Client 需要一个ca.crt ，服务器需要 `server.crt` 和 `server.key` 。
- 双向认证，指的是相互校验，Server 需要校验每个 Client ，Client 也需要校验服务器。Server 需要 `server.key`、`server.crt`、`ca.crt` 。Client 需要 `client.key`、`client.crt`、`ca.crt` 。
***
Q：单向认证的过程是什么？  
A：如下图所示：  
![](http://static.iocoder.cn/bdf6be06c37bcc026ed906f392661e3b)
***
Q：双向认证的过程是什么？  
A：如下图所示：  
![](http://static.iocoder.cn/61ed2a8b189fc549a9c7407c2ebedb64)
***
Q：如何选择单向认证还是双向认证？  
A：一般一个站点很多用户访问就用单向认证。企业接口对接就用双向认证。
***
Q：为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢？  
A：不是说HTTPS在网络中传输的是密文吗？这个问题就是中间者攻击（man in zhe middle）。  
![](http://static.iocoder.cn/0332b5d6001f7446a04a5d54b9b93d7e)

- 解决办法，就是 HTTPS 单向验证。在客户端中内置服务器公钥，在第三步服务器返回的公钥，除了验证公钥的有效性之外，再比对公钥是不是和内置的公钥一样，不一样说明被中间者攻击了，就断开链接不在请求了。
- 这个原理的前提是服务器的私钥没有泄露，客户端的代码不会被破解，道高一尺魔高一丈。信息安全就是在合理的范围内，选择比较合适的加密方法，没有绝对论，只有相对论。在某个范围内比较安全。
***
Q：HTTPS 握手会影响性能么？  
A：TCP 有三次握手，再加上 HTTPS 的四次握手，影响肯定有，但是可以接受。  
- 首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。
- 而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复 。
- 除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。
- 如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。
***
Q：SPDY 是什么？  
A：2012 年，Google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：  
1. 降低延迟：SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 Stream 共享一个 Tcp连 接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。
2. 请求优先级（request prioritization）：多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。
3. header 压缩：前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
4. 基于 HTTPS 的加密协议传输：大大提高了传输数据的安全性。
5. 服务端推送（server push）：在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端。当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。
![](http://static.iocoder.cn/82cf7ea112281d126f23db03a502c249)

***
Q：什么是 HTTP2.0 ？  
A：HTTP2.0 ，可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：  
- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS 。
- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE 。
***
Q：HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？  
A：区别如下：  
- HTTP/1.0：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接。
- HTTP/1.1：Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会。一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。
- HTTP/2：多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。
![](http://static.iocoder.cn/7268e2a2553c6612396b7de03667d348)
***
Q：HTTP2.0 多路复用有多好？  
A：HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。  
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。  
***
Q：服务器推送到底是什么？  
A：服务端推送能把客户端所需要的资源伴随着 `index.html` 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：
- 普通的客户端请求过程：
![](http://static.iocoder.cn/9eecd5ec56714731d0e38c6ef9c468d1)
- 服务端推送的过程：
![](http://static.iocoder.cn/c30ec0b3743d1f9751d3ba511f94578b)
***
Q：为什么需要头部(header)压缩？  
A：假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的），而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 Cookie 和引用等东西的存在），则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP 头部，大大降低因头部传输产生的流量。  
- 维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合。
- 维护一份相同的动态字典（Dynamic Table），可以动态地添加内容。
- 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）。
***
Q：你在浏览器输入一个网址，按回车之后发生了什么？  
A：流程如下：  
1. 根据域名解析 IP。  
  - 查找浏览器本地缓存。
  - 调用系统缓存来查找DNS。
  - 发送请求到路由器上查询 DNS 缓存。
  - 发送请求到互联网提供商 ISP 去查询 DNS 环境。
  - ISP 服务向根域名服务器进行搜索，根域名服务服务器保存着完整的 DNS 数据库。
  - 还没找到就说明域名不存在。
2. 进行三次握手，建立 TCP 连接。
3. 浏览器发送 HTTP 请求，方式为 GET。
4. 服务器处理请求并返回数据。
5. 浏览器解析渲染页面。
  - 浏览器显示 HTML，此时网页还没有完整加载，但是页面已经开始显示了。
  - 浏览器像服务器发送请求，获取嵌入 HTML 中的对象。
6. 关闭 TCP 连接





